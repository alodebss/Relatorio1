<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Simula√ß√µes de Campo El√©trico</title>
<style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
            max-width: 800px;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .subtitle {
            font-size: 1.2rem;
            margin-bottom: 20px;
            opacity: 0.9;
        }
        
        .tabs {
            display: flex;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 10px 10px 0 0;
            overflow: hidden;
            margin-bottom: 0;
            width: 100%;
            max-width: 1200px;
        }
        
        .tab {
            padding: 15px 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            flex: 1;
            font-weight: bold;
        }
        
        .tab:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        
        .tab.active {
            background-color: rgba(255, 255, 255, 0.9);
            color: #1a2a6c;
        }
        
        .container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 30px;
            max-width: 1200px;
            width: 100%;
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 0 0 15px 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }
        
        .tab-content {
            display: none;
            width: 100%;
        }
        
        .tab-content.active {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
        }
        
        .simulation-panel {
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            border-radius: 15px;
            padding: 20px;
            flex: 1;
            min-width: 300px;
            max-width: 600px;
        }
        
        .explanation-panel {
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            border-radius: 15px;
            padding: 20px;
            flex: 1;
            min-width: 300px;
            max-width: 500px;
            display: flex;
            flex-direction: column;
        }
        
        canvas {
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            display: block;
            margin: 0 auto;
            cursor: grab;
        }
        
        .controls {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .charge-control {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        input[type="range"] {
            flex: 1;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
        }
        
        .charge-value {
            min-width: 70px;
            font-weight: bold;
            text-align: center;
            padding: 5px;
            border-radius: 5px;
        }
        
        .positive {
            background-color: rgba(255, 0, 0, 0.3);
        }
        
        .negative {
            background-color: rgba(0, 0, 255, 0.3);
        }
        
        .buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            background-color: #4a00e0;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 1;
        }
        
        button:hover {
            background-color: #8e2de2;
            transform: translateY(-2px);
        }
        
        .avatar-container {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .avatar {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, #8e2de2, #4a00e0);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 15px;
            font-size: 2rem;
            position: relative;
            animation: avatar-bounce 3s infinite ease-in-out;
        }
        
        .avatar::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.4) 0%, transparent 70%);
        }
        
        .speech-bubble {
            background-color: rgba(255, 255, 255, 0.9);
            color: #333;
            padding: 15px;
            border-radius: 20px;
            position: relative;
            flex: 1;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.5s ease;
            min-height: 80px;
            display: flex;
            align-items: center;
        }
        
        .speech-bubble.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .speech-bubble:after {
            content: '';
            position: absolute;
            left: -10px;
            top: 30px;
            width: 0;
            height: 0;
            border: 10px solid transparent;
            border-right-color: rgba(255, 255, 255, 0.9);
        }
        
        .explanation-content {
            background-color: rgba(255, 255, 255, 0.9);
            color: #333;
            padding: 20px;
            border-radius: 10px;
            flex: 1;
            overflow-y: auto;
            max-height: 300px;
        }
        
        .explanation-content h3 {
            margin-bottom: 15px;
            color: #4a00e0;
        }
        
        .explanation-content p {
            margin-bottom: 15px;
            line-height: 1.5;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }
        
        .positive-color {
            background-color: red;
        }
        
        .negative-color {
            background-color: blue;
        }
        
        .field-color {
            background-color: #00ff00;
        }
        
        .equipotential-color {
            background-color: #ff00ff;
        }
        
        .electrode-color {
            background-color: #ff9900;
        }
        
        .instructions {
            margin-top: 20px;
            text-align: center;
            font-style: italic;
            opacity: 0.8;
        }
        
        .electrode-controls {
            display: flex;
            gap: 15px;
            margin-top: 15px;
        }
        
        .electrode-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
        }
        
        .visualization-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .vis-checkbox {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .avatar-controls {
            display: flex;
            justify-content: center;
            margin-top: 10px;
            gap: 10px;
        }
        
        .avatar-controls button {
            padding: 8px 12px;
            font-size: 0.9rem;
        }
        
        @keyframes avatar-bounce {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-5px);
            }
        }
        
        @keyframes avatar-talk {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }
        
        .avatar.talking {
            animation: avatar-bounce 3s infinite ease-in-out, avatar-talk 0.5s infinite alternate;
        }
        
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .simulation-panel, .explanation-panel {
                max-width: 100%;
            }
            
            .tabs {
                flex-direction: column;
            }
            
            .electrode-controls {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
<div class="header">
<h1>Simula√ß√µes de Campo El√©trico</h1>
<p class="subtitle">Explore diferentes aspectos dos campos el√©tricos atrav√©s de simula√ß√µes interativas</p>
</div>
<div class="tabs">
<div class="tab active" data-tab="field-lines">Linhas de Campo</div>
<div class="tab" data-tab="electrolytic-tank">Cuba Eletrol√≠tica</div>
<div class="tab" data-tab="electric-field">Campo El√©trico</div>
<div class="tab" data-tab="magnetic-field">Campo Magn√©tico</div></div>
<div class="container">
<!-- Aba 1: Linhas de Campo entre Cargas Pontuais -->
<div class="tab-content active" id="field-lines">
<div class="simulation-panel">
<canvas height="400" id="fieldCanvas" width="550"></canvas>
<div class="controls">
<div class="charge-control">
<label for="charge1">Carga 1:</label>
<div class="slider-container">
<input id="charge1" max="100" min="-100" type="range" value="50"/>
<span class="charge-value positive" id="charge1Value">+50 ŒºC</span>
</div>
</div>
<div class="charge-control">
<label for="charge2">Carga 2:</label>
<div class="slider-container">
<input id="charge2" max="100" min="-100" type="range" value="-50"/>
<span class="charge-value negative" id="charge2Value">-50 ŒºC</span>
</div>
</div>
<div class="buttons">
<button id="resetBtn">Resetar Posi√ß√µes</button>
<button id="infoBtn">Mais Informa√ß√µes</button>
</div>
</div>
<div class="legend">
<div class="legend-item">
<div class="legend-color positive-color"></div>
<span>Carga Positiva</span>
</div>
<div class="legend-item">
<div class="legend-color negative-color"></div>
<span>Carga Negativa</span>
</div>
<div class="legend-item">
<div class="legend-color field-color"></div>
<span>Linhas de Campo</span>
</div>
</div>
<p class="instructions">Arraste as cargas para mov√™-las. Use os controles para alterar seus valores.</p>
</div>
<div class="explanation-panel">
<div class="avatar-container">
<div class="avatar">üë©‚Äçüî¨</div>
<div class="speech-bubble" id="avatarSpeech1">
                        Ol√°! Esta simula√ß√£o mostra as linhas de campo el√©trico entre duas cargas pontuais.
                    </div>
</div>
<div class="avatar-controls">
<button id="playBtn1">‚ñ∂Ô∏è Reproduzir Explica√ß√£o</button>
<button id="pauseBtn1">‚è∏Ô∏è Pausar</button>
</div>
<div class="explanation-content">
<h3>Linhas de Campo El√©trico</h3>
<p>As linhas de campo el√©trico s√£o uma representa√ß√£o visual que mostra a dire√ß√£o e intensidade do campo el√©trico em cada ponto do espa√ßo.</p>
<p><strong>Caracter√≠sticas das linhas de campo:</strong></p>
<ul>
<li>Saem das cargas positivas e entram nas cargas negativas</li>
<li>A densidade das linhas √© proporcional √† intensidade do campo</li>
<li>Nunca se cruzam</li>
<li>S√£o perpendiculares √†s superf√≠cies condutoras</li>
</ul>
<p><strong>Como interpretar:</strong></p>
<p>Onde as linhas est√£o mais pr√≥ximas, o campo el√©trico √© mais intenso. O sentido das setas indica a dire√ß√£o que uma carga positiva seguiria se colocada naquele ponto.</p>
</div>
</div>
</div>
<!-- Aba 2: Cuba Eletrol√≠tica com Placas Paralelas -->
<div class="tab-content" id="electrolytic-tank">
<div class="simulation-panel">
<canvas height="400" id="tankCanvas" width="550"></canvas>
<div class="controls">
<div class="electrode-controls">
<div class="electrode-control">
<label for="plateDistance">Dist√¢ncia entre Placas:</label>
<input id="plateDistance" max="300" min="100" type="range" value="200"/>
<span id="plateDistanceValue">200 px</span>
</div>
<div class="electrode-control">
<label for="plateHeight">Altura das Placas:</label>
<input id="plateHeight" max="200" min="80" type="range" value="160"/>
<span id="plateHeightValue">160 px</span>
</div>
</div>
<div class="electrode-controls">
<div class="electrode-control">
<label for="voltage">Tens√£o (V):</label>
<input id="voltage" max="20" min="1" type="range" value="12"/>
<span id="voltageValue">12 V</span>
</div>
</div>
<div class="visualization-controls">
<div class="vis-checkbox">
<input checked="" id="showFieldLines" type="checkbox"/>
<label for="showFieldLines">Mostrar Linhas de Campo</label>
</div>
<div class="vis-checkbox">
<input checked="" id="showEquipotentials" type="checkbox"/>
<label for="showEquipotentials">Mostrar Equipotenciais</label>
</div>
</div>
<div class="buttons">
<button id="infoTankBtn">Mais Informa√ß√µes</button>
</div>
</div>
<div class="legend">
<div class="legend-item">
<div class="legend-color electrode-color"></div>
<span>Eletrodos</span>
</div>
<div class="legend-item">
<div class="legend-color field-color"></div>
<span>Linhas de Campo</span>
</div>
<div class="legend-item">
<div class="legend-color equipotential-color"></div>
<span>Linhas Equipotenciais</span>
</div>
</div>
<p class="instructions">Ajuste a dist√¢ncia entre as placas, altura das placas e a tens√£o aplicada.</p>
</div>
<div class="explanation-panel">
<div class="avatar-container">
<div class="avatar">üë©‚Äçüî¨</div>
<div class="speech-bubble" id="avatarSpeech2">
                        Esta √© uma simula√ß√£o do experimento da cuba eletrol√≠tica com placas paralelas.
                    </div>
</div>
<div class="avatar-controls">
<button id="playBtn2">‚ñ∂Ô∏è Reproduzir Explica√ß√£o</button>
<button id="pauseBtn2">‚è∏Ô∏è Pausar</button>
</div>
<div class="explanation-content">
<h3>Cuba Eletrol√≠tica - Placas Paralelas</h3>
<p>O experimento da cuba eletrol√≠tica √© um m√©todo cl√°ssico para visualizar linhas equipotenciais e campos el√©tricos em duas dimens√µes.</p>
<p><strong>Placas Paralelas:</strong></p>
<ul>
<li>Criam um campo el√©trico quase uniforme entre as placas</li>
<li>As linhas de campo s√£o retas e paralelas</li>
<li>As linhas equipotenciais s√£o perpendiculares √†s linhas de campo</li>
<li>O campo √© mais intenso quando as placas est√£o mais pr√≥ximas</li>
<li>Placas maiores criam uma regi√£o de campo uniforme mais extensa</li>
</ul>
<p><strong>Como interpretar:</strong></p>
<p>As linhas verdes mostram a dire√ß√£o do campo el√©trico. As linhas roxas conectam pontos com o mesmo potencial el√©trico. Note que elas s√£o sempre perpendiculares entre si!</p>
<p><strong>Equa√ß√µes importantes:</strong></p>
<p>Campo el√©trico: E = V/d</p>
<p>Onde V √© a tens√£o e d √© a dist√¢ncia entre as placas</p>
</div>
</div>
</div>
<!-- Aba 3: Campo El√©trico -->
<div class="tab-content" id="electric-field">
<div class="simulation-panel">
<canvas height="400" id="vectorFieldCanvas" width="550"></canvas>
<div class="controls">
<div class="charge-control">
<label for="charge5">Carga 1:</label>
<div class="slider-container">
<input id="charge5" max="100" min="-100" type="range" value="60"/>
<span class="charge-value positive" id="charge5Value">+60 ŒºC</span>
</div>
</div>
<div class="charge-control">
<label for="charge6">Carga 2:</label>
<div class="slider-container">
<input id="charge6" max="100" min="-100" type="range" value="60"/>
<span class="charge-value positive" id="charge6Value">+60 ŒºC</span>
</div>
</div>
<div class="buttons">
<button id="resetVectorBtn">Resetar Posi√ß√µes</button>
<button id="infoVectorBtn">Mais Informa√ß√µes</button>
</div>
</div>
<div class="legend">
<div class="legend-item">
<div class="legend-color positive-color"></div>
<span>Carga Positiva</span>
</div>
<div class="legend-item">
<div class="legend-color negative-color"></div>
<span>Carga Negativa</span>
</div>
<div class="legend-item">
<div class="legend-color field-color"></div>
<span>Vetores de Campo</span>
</div>
</div>
<p class="instructions">Arraste as cargas para mov√™-las. Os vetores mostram a dire√ß√£o e magnitude do campo.</p>
</div>
<div class="explanation-panel">
<div class="avatar-container">
<div class="avatar">üë©‚Äçüî¨</div>
<div class="speech-bubble" id="avatarSpeech3">
                        Aqui voc√™ v√™ uma representa√ß√£o vetorial do campo el√©trico. Cada vetor mostra dire√ß√£o e intensidade.
                    </div>
</div>
<div class="avatar-controls">
<button id="playBtn3">‚ñ∂Ô∏è Reproduzir Explica√ß√£o</button>
<button id="pauseBtn3">‚è∏Ô∏è Pausar</button>
</div>
<div class="explanation-content">
<h3>Campo El√©trico Vetorial</h3>
<p>O campo el√©trico √© uma grandeza vetorial, possuindo magnitude e dire√ß√£o em cada ponto do espa√ßo.</p>
<p><strong>Caracter√≠sticas da representa√ß√£o vetorial:</strong></p>
<ul>
<li>Cada vetor mostra a dire√ß√£o que uma carga positiva seguiria</li>
<li>O comprimento do vetor √© proporcional √† intensidade do campo</li>
<li>Vetores mais longos indicam campos mais intensos</li>
<li>O campo √© mais forte pr√≥ximo √†s cargas</li>
</ul>
<p><strong>Como interpretar:</strong></p>
<p>Observe como os vetores apontam para longe das cargas positivas e em dire√ß√£o √†s cargas negativas. Onde os vetores s√£o mais longos e pr√≥ximos, o campo el√©trico √© mais intenso.</p>
<p><strong>F√≥rmula do campo el√©trico:</strong></p>
<p>E = k * q / r¬≤ (Lei de Coulomb)</p>
</div>
</div>
</div>

<div class="tab-content" id="magnetic-field">
<div class="simulation-panel">
<canvas height="400" id="magneticCanvas" width="550"></canvas>
<div class="controls">
<div class="charge-control">
<label for="current">Corrente (I):</label>
<div class="slider-container">
<input id="current" max="20" min="0" type="range" value="10"/>
<span class="charge-value positive" id="currentValue">+10 A</span>
</div>
</div>
<div class="charge-control">
<label>Sentido da Corrente:</label>
<div class="buttons">
<button id="intoPageBtn">‚äó Para dentro da tela</button>
<button id="outPageBtn">‚äô Para fora da tela</button>
</div>
</div>
<div class="buttons">
<button id="infoMagBtn">Mais Informa√ß√µes</button>
</div>
</div>
<div class="legend">
<div class="legend-item">
<div class="legend-color field-color"></div>
<span>Linhas de Campo Magn√©tico</span>
</div>
</div>
<p class="instructions">Use os controles para alterar a corrente e o sentido. Observe o sentido das linhas conforme a regra da m√£o direita.</p>
</div>
<div class="explanation-panel">
<div class="avatar-container">
<div class="avatar">üë©‚Äçüî¨</div>
<div class="speech-bubble" id="avatarSpeech4">
                O campo magn√©tico gerado por um fio retil√≠neo √© circular e depende do sentido da corrente.
            </div>
</div>
<div class="avatar-controls">
<button id="playBtn4">‚ñ∂Ô∏è Reproduzir Explica√ß√£o</button>
<button id="pauseBtn4">‚è∏Ô∏è Pausar</button>
</div>
<div class="explanation-content">
<h3>Campo Magn√©tico ao Redor de um Fio Retil√≠neo</h3>
<p>Quando uma corrente el√©trica percorre um fio, forma-se um campo magn√©tico ao seu redor. As linhas de campo s√£o circulares e conc√™ntricas ao fio.</p>
<p><strong>Sentido do campo:</strong></p>
<ul>
<li>Use a <em>regra da m√£o direita</em> ‚Äî o polegar indica o sentido da corrente, e os dedos mostram o sentido do campo magn√©tico.</li>
<li>Corrente <strong>saindo da tela (‚äô)</strong> ‚Üí campo anti-hor√°rio.</li>
<li>Corrente <strong>entrando da tela (‚äó)</strong> ‚Üí campo hor√°rio.</li>
</ul>
<p><strong>Intensidade do campo:</strong></p>
<p>O campo magn√©tico √© dado por:</p>
<p><code>B = Œº‚ÇÄ I / (2œÄr)</code></p>
<p>onde <code>Œº‚ÇÄ</code> √© a permeabilidade do v√°cuo, <code>I</code> a corrente e <code>r</code> a dist√¢ncia ao fio.</p>
</div>
</div>
</div>
</div>
<script>
    // ========== SISTEMA DE VOZ FEMININA ==========
    
    // Verificar suporte √† API de s√≠ntese de voz
    const speechSupported = 'speechSynthesis' in window;
    
    // Inst√¢ncia da s√≠ntese de voz
    let currentSpeech = null;
    let femaleVoice = null;
    
    // Fun√ß√£o para encontrar uma voz feminina
    function findFemaleVoice() {
        if (!speechSupported) return null;
        
        const voices = speechSynthesis.getVoices();
        
        // Procurar por vozes femininas em portugu√™s
        const femaleVoices = voices.filter(voice => {
            // Verificar se a voz √© feminina (baseado no nome ou idioma)
            const voiceName = voice.name.toLowerCase();
            return (
                voice.lang.startsWith('pt') && 
                (voiceName.includes('feminina') || 
                 voiceName.includes('female') || 
                 voiceName.includes('mulher') ||
                 voiceName.includes('woman') ||
                 voiceName.includes('ana') ||
                 voiceName.includes('maria') ||
                 voiceName.includes('lucia'))
            );
        });
        
        // Se n√£o encontrar uma voz explicitamente feminina, usar a primeira voz em portugu√™s
        if (femaleVoices.length > 0) {
            return femaleVoices[0];
        } else {
            const portugueseVoices = voices.filter(voice => voice.lang.startsWith('pt'));
            return portugueseVoices.length > 0 ? portugueseVoices[0] : null;
        }
    }
    
    // Inicializar a voz quando as vozes estiverem carregadas
    function initializeVoice() {
        if (!speechSupported) return;
        
        // Tentar encontrar uma voz feminina
        femaleVoice = findFemaleVoice();
        
        // Se n√£o encontrou, tentar novamente ap√≥s um tempo (as vozes podem carregar assincronamente)
        if (!femaleVoice) {
            setTimeout(() => {
                femaleVoice = findFemaleVoice();
                console.log("Voz feminina carregada:", femaleVoice ? femaleVoice.name : "N√£o encontrada");
            }, 1000);
        } else {
            console.log("Voz feminina selecionada:", femaleVoice.name);
        }
    }
    
    // Carregar vozes quando estiverem dispon√≠veis
    if (speechSupported) {
        if (speechSynthesis.getVoices().length > 0) {
            initializeVoice();
        } else {
            speechSynthesis.addEventListener('voiceschanged', initializeVoice);
        }
    }
    
    // Fun√ß√£o para falar texto com voz feminina
    function speakText(text, rate = 0.9, pitch = 1.1, volume = 1.0) {
        // Parar qualquer fala anterior
        stopSpeech();
        
        if (!speechSupported) {
            console.log("S√≠ntese de voz n√£o suportada neste navegador");
            return;
        }
        
        // Criar nova inst√¢ncia de fala
        const utterance = new SpeechSynthesisUtterance(text);
        
        // Configurar par√¢metros para voz feminina
        utterance.rate = rate;      // Velocidade um pouco mais lenta
        utterance.pitch = pitch;    // Tom mais agudo (feminino)
        utterance.volume = volume;
        utterance.lang = 'pt-BR';
        
        // Usar voz feminina se dispon√≠vel
        if (femaleVoice) {
            utterance.voice = femaleVoice;
        }
        
        // Evento quando a fala termina
        utterance.onend = function() {
            currentSpeech = null;
        };
        
        // Evento em caso de erro
        utterance.onerror = function(event) {
            console.error("Erro na s√≠ntese de voz:", event);
            currentSpeech = null;
        };
        
        // Iniciar fala
        speechSynthesis.speak(utterance);
        currentSpeech = utterance;
    }
    
    // Fun√ß√£o para parar a fala
    function stopSpeech() {
        if (speechSupported && speechSynthesis.speaking) {
            speechSynthesis.cancel();
            currentSpeech = null;
        }
    }
    
    // ========== SISTEMA DE ABAS ==========
    
    // Vari√°veis para controlar os intervalos de explica√ß√£o
    let fieldExplanationInterval;
    let tankExplanationInterval;
    let vectorExplanationInterval;
    let magneticExplanationInterval;
    
    // Vari√°veis para controlar os timeouts das mensagens
    let fieldMessageTimeout;
    let tankMessageTimeout;
    let vectorMessageTimeout;
    let magneticMessageTimeout;
    
    // Fun√ß√£o para parar TODAS as explica√ß√µes
    function stopAllExplanations() {
        // Parar todos os intervalos
        clearInterval(fieldExplanationInterval);
        clearInterval(tankExplanationInterval);
        clearInterval(vectorExplanationInterval);
        clearInterval(magneticExplanationInterval);
        
        // Parar todos os timeouts
        clearTimeout(fieldMessageTimeout);
        clearTimeout(tankMessageTimeout);
        clearTimeout(vectorMessageTimeout);
        clearTimeout(magneticMessageTimeout);
        
        // Parar a voz
        stopSpeech();
        
        // Remover anima√ß√µes dos avatares
        document.querySelectorAll('.avatar').forEach(avatar => {
            avatar.classList.remove('talking');
        });
        
        // Esconder bolhas de fala
        document.querySelectorAll('.speech-bubble').forEach(bubble => {
            bubble.classList.remove('show');
        });
    }
    
    document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
            // Parar TODAS as explica√ß√µes anteriores
            stopAllExplanations();
            
            // Remove a classe active de todas as abas e conte√∫dos
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            
            // Adiciona a classe active √† aba clicada e ao conte√∫do correspondente
            tab.classList.add('active');
            const tabId = tab.getAttribute('data-tab');
            document.getElementById(tabId).classList.add('active');
            
            // Inicia a explica√ß√£o autom√°tica quando mudar de aba
            if (tabId === 'field-lines') {
                startFieldExplanation();
            } else if (tabId === 'electrolytic-tank') {
                startTankExplanation();
            } else if (tabId === 'electric-field') {
                startVectorExplanation();
            } else if (tabId === 'magnetic-field') {
                startMagneticExplanation();
            }
        });
    });
    
    // ========== ANIMA√á√ÉO DO AVATAR ==========
    
    // Elementos do avatar
    const avatars = document.querySelectorAll('.avatar');
    const speechBubbles = document.querySelectorAll('.speech-bubble');
    
    // Fun√ß√£o para mostrar uma mensagem no avatar
    function showAvatarMessage(message, avatarIndex, duration = 5000) {
        const avatar = avatars[avatarIndex];
        const speechBubble = speechBubbles[avatarIndex];
        
        // Adiciona anima√ß√£o de fala
        avatar.classList.add('talking');
        
        // Mostra a bolha de fala
        speechBubble.textContent = message;
        speechBubble.classList.add('show');
        
        // Falar o texto com voz feminina
        speakText(message);
        
        // Remove a anima√ß√£o ap√≥s um tempo
        setTimeout(() => {
            avatar.classList.remove('talking');
        }, duration - 1000);
        
        // Esconde a bolha de fala ap√≥s o tempo especificado
        setTimeout(() => {
            speechBubble.classList.remove('show');
        }, duration);
    }
    
    // ========== SISTEMA DE EXPLICA√á√ÉO AUTOM√ÅTICA ==========
    
    // Aba 1: Linhas de Campo
    const fieldMessages = [
        "Ol√°! Esta simula√ß√£o mostra as linhas de campo el√©trico entre duas cargas pontuais.",
        "As linhas de campo el√©trico mostram a dire√ß√£o do campo em cada ponto do espa√ßo.",
        "Elas saem das cargas positivas e entram nas cargas negativas.",
        "A densidade das linhas √© proporcional √† intensidade do campo el√©trico.",
        "Onde as linhas est√£o mais pr√≥ximas, o campo √© mais forte!",
        "As linhas de campo nunca se cruzam. Isso √© uma propriedade importante!",
        "Experimente alterar os valores das cargas para ver como o campo muda."
    ];
    
    function startFieldExplanation() {
        // Limpar qualquer explica√ß√£o anterior
        clearInterval(fieldExplanationInterval);
        clearTimeout(fieldMessageTimeout);
        
        let messageIndex = 0;
        
        // Mostra a primeira mensagem imediatamente
        showAvatarMessage(fieldMessages[messageIndex], 0, 6000);
        messageIndex++;
        
        // Configura o intervalo para as pr√≥ximas mensagens
        fieldExplanationInterval = setInterval(() => {
            if (messageIndex < fieldMessages.length) {
                showAvatarMessage(fieldMessages[messageIndex], 0, 6000);
                messageIndex++;
            } else {
                // Reinicia o ciclo
                messageIndex = 0;
                showAvatarMessage(fieldMessages[messageIndex], 0, 6000);
                messageIndex++;
            }
        }, 7000);
    }
    
    // Aba 2: Cuba Eletrol√≠tica
    const tankMessages = [
        "Esta √© uma simula√ß√£o do experimento da cuba eletrol√≠tica com placas paralelas.",
        "A cuba eletrol√≠tica √© usada para visualizar campos el√©tricos em 2D.",
        "As placas paralelas criam um campo el√©trico quase uniforme entre elas.",
        "As linhas verdes mostram a dire√ß√£o do campo el√©trico.",
        "As linhas roxas s√£o equipotenciais - pontos com o mesmo potencial.",
        "Note que as linhas de campo e equipotenciais s√£o sempre perpendiculares!",
        "O campo el√©trico √© calculado por E = V/d, onde V √© a tens√£o e d √© a dist√¢ncia.",
        "Experimente alterar a dist√¢ncia entre as placas para ver como o campo muda."
    ];
    
    function startTankExplanation() {
        // Limpar qualquer explica√ß√£o anterior
        clearInterval(tankExplanationInterval);
        clearTimeout(tankMessageTimeout);
        
        let messageIndex = 0;
        
        // Mostra a primeira mensagem imediatamente
        showAvatarMessage(tankMessages[messageIndex], 1, 6000);
        messageIndex++;
        
        // Configura o intervalo para as pr√≥ximas mensagens
        tankExplanationInterval = setInterval(() => {
            if (messageIndex < tankMessages.length) {
                showAvatarMessage(tankMessages[messageIndex], 1, 6000);
                messageIndex++;
            } else {
                // Reinicia o ciclo
                messageIndex = 0;
                showAvatarMessage(tankMessages[messageIndex], 1, 6000);
                messageIndex++;
            }
        }, 7000);
    }
    
    // Aba 3: Campo El√©trico Vetorial
    const vectorMessages = [
        "Aqui voc√™ v√™ uma representa√ß√£o vetorial do campo el√©trico.",
        "Cada vetor mostra a dire√ß√£o e intensidade do campo em um ponto.",
        "Vetores mais longos indicam campos mais intensos.",
        "Os vetores apontam para longe das cargas positivas.",
        "E apontam em dire√ß√£o √†s cargas negativas.",
        "O campo √© mais forte pr√≥ximo √†s cargas, onde os vetores s√£o maiores.",
        "A f√≥rmula do campo √© E = k * q / r¬≤ (Lei de Coulomb).",
        "Experimente mover as cargas para ver como os vetores mudam."
    ];
    
    function startVectorExplanation() {
        // Limpar qualquer explica√ß√£o anterior
        clearInterval(vectorExplanationInterval);
        clearTimeout(vectorMessageTimeout);
        
        let messageIndex = 0;
        
        // Mostra a primeira mensagem imediatamente
        showAvatarMessage(vectorMessages[messageIndex], 2, 6000);
        messageIndex++;
        
        // Configura o intervalo para as pr√≥ximas mensagens
        vectorExplanationInterval = setInterval(() => {
            if (messageIndex < vectorMessages.length) {
                showAvatarMessage(vectorMessages[messageIndex], 2, 6000);
                messageIndex++;
            } else {
                // Reinicia o ciclo
                messageIndex = 0;
                showAvatarMessage(vectorMessages[messageIndex], 2, 6000);
                messageIndex++;
            }
        }, 7000);
    }
    
    // Aba 4: Campo Magn√©tico
    const magneticMessages = [
        "Aqui temos o campo magn√©tico gerado por um fio percorrido por corrente el√©trica.",
        "As linhas s√£o circulares e conc√™ntricas ao fio.",
        "O sentido do campo √© determinado pela regra da m√£o direita.",
        "Corrente saindo da tela: campo anti-hor√°rio.",
        "Corrente entrando da tela: campo hor√°rio.",
        "A intensidade do campo √© B = Œº‚ÇÄ vezes I dividido por 2œÄr.",
        "Experimente mudar o sentido da corrente e veja o campo girar!"
    ];
    
    function startMagneticExplanation() {
        // Limpar qualquer explica√ß√£o anterior
        clearInterval(magneticExplanationInterval);
        clearTimeout(magneticMessageTimeout);
        
        let messageIndex = 0;
        
        // Mostra a primeira mensagem imediatamente
        showAvatarMessage(magneticMessages[messageIndex], 3, 6000);
        messageIndex++;
        
        // Configura o intervalo para as pr√≥ximas mensagens
        magneticExplanationInterval = setInterval(() => {
            if (messageIndex < magneticMessages.length) {
                showAvatarMessage(magneticMessages[messageIndex], 3, 6000);
                messageIndex++;
            } else {
                // Reinicia o ciclo
                messageIndex = 0;
                showAvatarMessage(magneticMessages[messageIndex], 3, 6000);
                messageIndex++;
            }
        }, 7000);
    }
    
    // Controles de reprodu√ß√£o para cada aba
    document.getElementById('playBtn1').addEventListener('click', startFieldExplanation);
    document.getElementById('pauseBtn1').addEventListener('click', () => {
        clearInterval(fieldExplanationInterval);
        clearTimeout(fieldMessageTimeout);
        avatars[0].classList.remove('talking');
        speechBubbles[0].classList.remove('show');
        stopSpeech();
    });
    
    document.getElementById('playBtn2').addEventListener('click', startTankExplanation);
    document.getElementById('pauseBtn2').addEventListener('click', () => {
        clearInterval(tankExplanationInterval);
        clearTimeout(tankMessageTimeout);
        avatars[1].classList.remove('talking');
        speechBubbles[1].classList.remove('show');
        stopSpeech();
    });
    
    document.getElementById('playBtn3').addEventListener('click', startVectorExplanation);
    document.getElementById('pauseBtn3').addEventListener('click', () => {
        clearInterval(vectorExplanationInterval);
        clearTimeout(vectorMessageTimeout);
        avatars[2].classList.remove('talking');
        speechBubbles[2].classList.remove('show');
        stopSpeech();
    });
    
    document.getElementById('playBtn4').addEventListener('click', startMagneticExplanation);
    document.getElementById('pauseBtn4').addEventListener('click', () => {
        clearInterval(magneticExplanationInterval);
        clearTimeout(magneticMessageTimeout);
        avatars[3].classList.remove('talking');
        speechBubbles[3].classList.remove('show');
        stopSpeech();
    });
    
    // ========== ABA 1: LINHAS DE CAMPO ==========
    const fieldCanvas = document.getElementById('fieldCanvas');
    const fieldCtx = fieldCanvas.getContext('2d');
    
    // Elementos de controle da aba 1
    const charge1Slider = document.getElementById('charge1');
    const charge2Slider = document.getElementById('charge2');
    const charge1Value = document.getElementById('charge1Value');
    const charge2Value = document.getElementById('charge2Value');
    const resetBtn = document.getElementById('resetBtn');
    const infoBtn = document.getElementById('infoBtn');
    
    // Estado das cargas da aba 1
    let chargesField = [
        { x: 150, y: 200, q: 50, radius: 20, dragging: false },
        { x: 400, y: 200, q: -50, radius: 20, dragging: false }
    ];
    
    // Constante de proporcionalidade
    const k = 100000;
    
    // Atualizar os valores das cargas nos controles da aba 1
    function updateFieldChargeValues() {
        const charge1Sign = chargesField[0].q > 0 ? '+' : '';
        const charge2Sign = chargesField[1].q > 0 ? '+' : '';
        
        charge1Value.textContent = `${charge1Sign}${chargesField[0].q} ŒºC`;
        charge2Value.textContent = `${charge2Sign}${chargesField[1].q} ŒºC`;
        
        charge1Value.className = `charge-value ${chargesField[0].q > 0 ? 'positive' : 'negative'}`;
        charge2Value.className = `charge-value ${chargesField[1].q > 0 ? 'positive' : 'negative'}`;
    }
    
    // Calcular o campo el√©trico em um ponto (x, y) na aba 1
    function calculateField(x, y, charges) {
        let Ex = 0, Ey = 0;
        
        for (const charge of charges) {
            const dx = x - charge.x;
            const dy = y - charge.y;
            const rSquared = dx * dx + dy * dy;
            
            if (rSquared < 1) continue;
            
            const r = Math.sqrt(rSquared);
            const E = k * charge.q / rSquared;
            
            Ex += E * dx / r;
            Ey += E * dy / r;
        }
        
        return { Ex, Ey };
    }
    
    // Desenhar uma seta na aba 1
    function drawFieldArrow(x, y, angle, length) {
        const headLength = 10;
        const headAngle = Math.PI / 6;
        
        fieldCtx.beginPath();
        fieldCtx.moveTo(x, y);
        fieldCtx.lineTo(x + length * Math.cos(angle), y + length * Math.sin(angle));
        fieldCtx.stroke();
        
        fieldCtx.beginPath();
        fieldCtx.moveTo(x + length * Math.cos(angle), y + length * Math.sin(angle));
        fieldCtx.lineTo(
            x + length * Math.cos(angle) - headLength * Math.cos(angle - headAngle),
            y + length * Math.sin(angle) - headLength * Math.sin(angle - headAngle)
        );
        fieldCtx.lineTo(
            x + length * Math.cos(angle) - headLength * Math.cos(angle + headAngle),
            y + length * Math.sin(angle) - headLength * Math.sin(angle + headAngle)
        );
        fieldCtx.closePath();
        fieldCtx.fill();
    }
    
    // Desenhar as linhas de campo na aba 1
    function drawFieldLines() {
        const gradient = fieldCtx.createLinearGradient(0, 0, fieldCanvas.width, fieldCanvas.height);
        gradient.addColorStop(0, 'rgba(10, 20, 40, 0.8)');
        gradient.addColorStop(1, 'rgba(5, 10, 20, 0.9)');
        fieldCtx.fillStyle = gradient;
        fieldCtx.fillRect(0, 0, fieldCanvas.width, fieldCanvas.height);
        
        // Desenhar linhas de campo com setas
        fieldCtx.strokeStyle = '#00ff00';
        fieldCtx.fillStyle = '#00ff00';
        fieldCtx.lineWidth = 1.5;
        
        const step = 5;
        const arrowSpacing = 25;
        
        for (const charge of chargesField) {
            const numLines = Math.min(24, Math.abs(charge.q) * 0.4 + 8);
            
            for (let i = 0; i < numLines; i++) {
                const angle = (i / numLines) * Math.PI * 2;
                
                let x, y;
                if (charge.q > 0) {
                    x = charge.x + (charge.radius + 5) * Math.cos(angle);
                    y = charge.y + (charge.radius + 5) * Math.sin(angle);
                } else {
                    x = charge.x + 250 * Math.cos(angle);
                    y = charge.y + 250 * Math.sin(angle);
                }
                
                fieldCtx.beginPath();
                fieldCtx.moveTo(x, y);
                
                let totalLength = 0;
                let steps = 0;
                
                while (steps < 300) {
                    const field = calculateField(x, y, chargesField);
                    const magnitude = Math.sqrt(field.Ex * field.Ex + field.Ey * field.Ey);
                    
                    if (magnitude < 0.1) break;
                    
                    let dx, dy;
                    if (charge.q > 0) {
                        dx = field.Ex / magnitude;
                        dy = field.Ey / magnitude;
                    } else {
                        dx = -field.Ex / magnitude;
                        dy = -field.Ey / magnitude;
                    }
                    
                    x += dx * step;
                    y += dy * step;
                    totalLength += step;
                    
                    if (x < 0 || x > fieldCanvas.width || y < 0 || y > fieldCanvas.height) break;
                    
                    // Desenhar seta periodicamente
                    if (totalLength % arrowSpacing < step) {
                        const arrowAngle = Math.atan2(dy, dx);
                        drawFieldArrow(x, y, arrowAngle, 10);
                    }
                    
                    fieldCtx.lineTo(x, y);
                    
                    let tooClose = false;
                    for (const otherCharge of chargesField) {
                        if (otherCharge === charge) continue;
                        const dist = Math.sqrt((x - otherCharge.x) ** 2 + (y - otherCharge.y) ** 2);
                        if (dist < otherCharge.radius + 5) {
                            tooClose = true;
                            break;
                        }
                    }
                    if (tooClose) break;
                    
                    steps++;
                }
                
                fieldCtx.stroke();
            }
        }
        
        // Desenhar as cargas
        for (const charge of chargesField) {
            fieldCtx.beginPath();
            fieldCtx.arc(charge.x, charge.y, charge.radius, 0, Math.PI * 2);
            
            if (charge.q > 0) {
                fieldCtx.fillStyle = 'red';
            } else if (charge.q < 0) {
                fieldCtx.fillStyle = 'blue';
            } else {
                fieldCtx.fillStyle = 'gray';
            }
            
            fieldCtx.fill();
            fieldCtx.strokeStyle = 'white';
            fieldCtx.lineWidth = 2;
            fieldCtx.stroke();
            
            fieldCtx.fillStyle = 'white';
            fieldCtx.font = 'bold 16px Arial';
            fieldCtx.textAlign = 'center';
            fieldCtx.textBaseline = 'middle';
            
            if (charge.q > 0) {
                fieldCtx.fillText('+', charge.x, charge.y);
            } else if (charge.q < 0) {
                fieldCtx.fillText('-', charge.x, charge.y);
            } else {
                fieldCtx.fillText('0', charge.x, charge.y);
            }
        }
    }
    
    // Event listeners para a aba 1
    charge1Slider.addEventListener('input', () => {
        chargesField[0].q = parseInt(charge1Slider.value);
        updateFieldChargeValues();
        drawFieldLines();
    });
    
    charge2Slider.addEventListener('input', () => {
        chargesField[1].q = parseInt(charge2Slider.value);
        updateFieldChargeValues();
        drawFieldLines();
    });
    
    resetBtn.addEventListener('click', () => {
        chargesField[0].x = 150;
        chargesField[0].y = 200;
        chargesField[1].x = 400;
        chargesField[1].y = 200;
        chargesField[0].q = 50;
        chargesField[1].q = -50;
        charge1Slider.value = 50;
        charge2Slider.value = -50;
        updateFieldChargeValues();
        drawFieldLines();
    });
    
    infoBtn.addEventListener('click', () => {
        showAvatarMessage("As linhas de campo el√©trico s√£o uma ferramenta visual poderosa para entender como cargas interagem √† dist√¢ncia!", 0, 5000);
    });
    
    // Event listeners para intera√ß√£o com o mouse na aba 1
    fieldCanvas.addEventListener('mousedown', (e) => {
        const rect = fieldCanvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        for (const charge of chargesField) {
            const dx = mouseX - charge.x;
            const dy = mouseY - charge.y;
            if (dx * dx + dy * dy <= charge.radius * charge.radius) {
                charge.dragging = true;
                fieldCanvas.style.cursor = 'grabbing';
                break;
            }
        }
    });
    
    fieldCanvas.addEventListener('mousemove', (e) => {
        const rect = fieldCanvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        let overCharge = false;
        for (const charge of chargesField) {
            if (charge.dragging) {
                charge.x = mouseX;
                charge.y = mouseY;
                drawFieldLines();
            } else if (isMouseOverFieldCharge(mouseX, mouseY, charge)) {
                overCharge = true;
            }
        }
        
        fieldCanvas.style.cursor = overCharge ? 'grab' : 'default';
    });
    
    fieldCanvas.addEventListener('mouseup', () => {
        for (const charge of chargesField) {
            charge.dragging = false;
        }
        fieldCanvas.style.cursor = 'default';
    });
    
    // Verificar se o mouse est√° sobre uma carga na aba 1
    function isMouseOverFieldCharge(mouseX, mouseY, charge) {
        const dx = mouseX - charge.x;
        const dy = mouseY - charge.y;
        return dx * dx + dy * dy <= charge.radius * charge.radius;
    }
    
    // ========== ABA 2: CUBA ELETROL√çTICA COM PLACAS PARALELAS ==========
    const tankCanvas = document.getElementById('tankCanvas');
    const tankCtx = tankCanvas.getContext('2d');
    
    // Elementos de controle da aba 2
    const plateDistanceSlider = document.getElementById('plateDistance');
    const plateDistanceValue = document.getElementById('plateDistanceValue');
    const plateHeightSlider = document.getElementById('plateHeight');
    const plateHeightValue = document.getElementById('plateHeightValue');
    const voltageSlider = document.getElementById('voltage');
    const voltageValue = document.getElementById('voltageValue');
    const showFieldLinesCheckbox = document.getElementById('showFieldLines');
    const showEquipotentialsCheckbox = document.getElementById('showEquipotentials');
    const infoTankBtn = document.getElementById('infoTankBtn');
    
    // Estado da cuba eletrol√≠tica
    let electrodes = [];
    let plateDistance = 200;
    let plateHeight = 160;
    let voltage = 12;
    let showFieldLines = true;
    let showEquipotentials = true;
    
    // Inicializar eletrodos (placas paralelas)
    function initializeElectrodes() {
        electrodes = [];
        const centerX = tankCanvas.width / 2;
        const centerY = tankCanvas.height / 2;
        
        // Placa positiva (esquerda)
        electrodes.push({
            type: 'plate',
            x: centerX - plateDistance / 2 - 5,
            y: centerY - plateHeight / 2,
            width: 10,
            height: plateHeight,
            voltage: voltage
        });
        
        // Placa negativa (direita)
        electrodes.push({
            type: 'plate',
            x: centerX + plateDistance / 2 - 5,
            y: centerY - plateHeight / 2,
            width: 10,
            height: plateHeight,
            voltage: 0
        });
    }
    
    // Desenhar a cuba eletrol√≠tica
    function drawTank() {
        // Fundo da cuba (√°gua)
        const waterGradient = tankCtx.createLinearGradient(0, 0, tankCanvas.width, tankCanvas.height);
        waterGradient.addColorStop(0, 'rgba(100, 150, 255, 0.3)');
        waterGradient.addColorStop(1, 'rgba(50, 100, 200, 0.5)');
        tankCtx.fillStyle = waterGradient;
        tankCtx.fillRect(0, 0, tankCanvas.width, tankCanvas.height);
        
        // Borda da cuba
        tankCtx.strokeStyle = '#8B4513';
        tankCtx.lineWidth = 5;
        tankCtx.strokeRect(5, 5, tankCanvas.width - 10, tankCanvas.height - 10);
        
        // Desenhar linhas de campo se habilitado
        if (showFieldLines) {
            drawFieldLinesTank();
        }
        
        // Desenhar linhas equipotenciais se habilitado
        if (showEquipotentials) {
            drawEquipotentialLines();
        }
        
        // Desenhar eletrodos
        drawElectrodes();
    }
    
    // Desenhar linhas de campo el√©trico
    function drawFieldLinesTank() {
        const leftPlate = electrodes[0];
        const rightPlate = electrodes[1];
        const leftEdge = leftPlate.x + leftPlate.width;
        const rightEdge = rightPlate.x;
        
        tankCtx.strokeStyle = '#00ff00';
        tankCtx.fillStyle = '#00ff00';
        tankCtx.lineWidth = 1.5;
        
        // N√∫mero de linhas de campo baseado na altura das placas
        const numLines = Math.max(8, Math.floor(plateHeight / 20));
        const stepY = leftPlate.height / (numLines - 1);
        
        for (let i = 0; i < numLines; i++) {
            const startY = leftPlate.y + i * stepY;
            
            // Linha saindo da placa positiva
            tankCtx.beginPath();
            tankCtx.moveTo(leftEdge, startY);
            
            // Linha reta at√© a placa negativa (campo uniforme)
            tankCtx.lineTo(rightEdge, startY);
            tankCtx.stroke();
            
            // Seta no final
            const arrowLength = 10;
            tankCtx.beginPath();
            tankCtx.moveTo(rightEdge, startY);
            tankCtx.lineTo(rightEdge - arrowLength, startY - arrowLength/2);
            tankCtx.lineTo(rightEdge - arrowLength, startY + arrowLength/2);
            tankCtx.closePath();
            tankCtx.fill();
        }
    }
    
    // Desenhar linhas equipotenciais
    function drawEquipotentialLines() {
        const leftPlate = electrodes[0];
        const rightPlate = electrodes[1];
        
        tankCtx.strokeStyle = '#ff00ff';
        tankCtx.lineWidth = 2;
        tankCtx.setLineDash([5, 3]);
        
        // N√∫mero de linhas equipotenciais
        const numLines = 8;
        
        for (let i = 1; i < numLines; i++) {
            const potential = (i / numLines) * voltage;
            
            tankCtx.beginPath();
            
            // Calcular a posi√ß√£o x para este potencial
            const leftEdge = leftPlate.x + leftPlate.width;
            const rightEdge = rightPlate.x;
            const totalDistance = rightEdge - leftEdge;
            const x = leftEdge + totalDistance * (1 - potential / voltage);
            
            // Linha vertical (equipotencial)
            tankCtx.moveTo(x, leftPlate.y);
            tankCtx.lineTo(x, leftPlate.y + leftPlate.height);
            tankCtx.stroke();
            
            // Valor do potencial
            tankCtx.fillStyle = 'white';
            tankCtx.font = '12px Arial';
            tankCtx.textAlign = 'center';
            tankCtx.textBaseline = 'top';
            tankCtx.fillText(potential.toFixed(1) + 'V', x, leftPlate.y + leftPlate.height + 5);
        }
        
        tankCtx.setLineDash([]);
    }
    
    // Desenhar eletrodos
    function drawElectrodes() {
        for (const electrode of electrodes) {
            tankCtx.fillStyle = '#ff9900'; // Cor laranja para eletrodos
            tankCtx.strokeStyle = '#cc7700';
            tankCtx.lineWidth = 2;
            
            tankCtx.fillRect(electrode.x, electrode.y, electrode.width, electrode.height);
            tankCtx.strokeRect(electrode.x, electrode.y, electrode.width, electrode.height);
            
            // Indicar polaridade
            tankCtx.fillStyle = 'white';
            tankCtx.font = 'bold 14px Arial';
            tankCtx.textAlign = 'center';
            tankCtx.textBaseline = 'middle';
            const polarity = electrode.voltage === voltage ? '+' : '-';
            tankCtx.fillText(polarity, electrode.x + electrode.width/2, electrode.y + electrode.height/2);
        }
    }
    
    // Event listeners para a aba 2
    plateDistanceSlider.addEventListener('input', () => {
        plateDistance = parseInt(plateDistanceSlider.value);
        plateDistanceValue.textContent = `${plateDistance} px`;
        initializeElectrodes();
        drawTank();
    });
    
    plateHeightSlider.addEventListener('input', () => {
        plateHeight = parseInt(plateHeightSlider.value);
        plateHeightValue.textContent = `${plateHeight} px`;
        initializeElectrodes();
        drawTank();
    });
    
    voltageSlider.addEventListener('input', () => {
        voltage = parseInt(voltageSlider.value);
        voltageValue.textContent = `${voltage} V`;
        
        // Atualizar tens√£o dos eletrodos
        electrodes[0].voltage = voltage;
        
        drawTank();
    });
    
    showFieldLinesCheckbox.addEventListener('change', () => {
        showFieldLines = showFieldLinesCheckbox.checked;
        drawTank();
    });
    
    showEquipotentialsCheckbox.addEventListener('change', () => {
        showEquipotentials = showEquipotentialsCheckbox.checked;
        drawTank();
    });
    
    infoTankBtn.addEventListener('click', () => {
        showAvatarMessage("Em um campo uniforme entre placas paralelas, a rela√ß√£o E = V/d mostra que o campo √© inversamente proporcional √† dist√¢ncia entre as placas!", 1, 5000);
    });
    
    // ========== ABA 3: CAMPO EL√âTRICO VETORIAL ==========
    const vectorFieldCanvas = document.getElementById('vectorFieldCanvas');
    const vectorFieldCtx = vectorFieldCanvas.getContext('2d');
    
    // Elementos de controle da aba 3
    const charge5Slider = document.getElementById('charge5');
    const charge6Slider = document.getElementById('charge6');
    const charge5Value = document.getElementById('charge5Value');
    const charge6Value = document.getElementById('charge6Value');
    const resetVectorBtn = document.getElementById('resetVectorBtn');
    const infoVectorBtn = document.getElementById('infoVectorBtn');
    
    // Estado das cargas da aba 3
    let chargesVector = [
        { x: 150, y: 200, q: 60, radius: 20, dragging: false },
        { x: 400, y: 200, q: 60, radius: 20, dragging: false }
    ];
    
    // Atualizar os valores das cargas nos controles da aba 3
    function updateVectorChargeValues() {
        const charge5Sign = chargesVector[0].q > 0 ? '+' : '';
        const charge6Sign = chargesVector[1].q > 0 ? '+' : '';
        
        charge5Value.textContent = `${charge5Sign}${chargesVector[0].q} ŒºC`;
        charge6Value.textContent = `${charge6Sign}${chargesVector[1].q} ŒºC`;
        
        charge5Value.className = `charge-value ${chargesVector[0].q > 0 ? 'positive' : 'negative'}`;
        charge6Value.className = `charge-value ${chargesVector[1].q > 0 ? 'positive' : 'negative'}`;
    }
    
    // Desenhar os vetores de campo
    function drawVectorField() {
        const gradient = vectorFieldCtx.createLinearGradient(0, 0, vectorFieldCanvas.width, vectorFieldCanvas.height);
        gradient.addColorStop(0, 'rgba(10, 20, 40, 0.8)');
        gradient.addColorStop(1, 'rgba(5, 10, 20, 0.9)');
        vectorFieldCtx.fillStyle = gradient;
        vectorFieldCtx.fillRect(0, 0, vectorFieldCanvas.width, vectorFieldCanvas.height);
        
        const gridSize = 30;
        vectorFieldCtx.strokeStyle = '#00ff00';
        vectorFieldCtx.fillStyle = '#00ff00';
        vectorFieldCtx.lineWidth = 1.5;
        
        for (let x = gridSize; x < vectorFieldCanvas.width; x += gridSize) {
            for (let y = gridSize; y < vectorFieldCanvas.height; y += gridSize) {
                const field = calculateField(x, y, chargesVector);
                const magnitude = Math.sqrt(field.Ex * field.Ex + field.Ey * field.Ey);
                
                if (magnitude < 0.1) continue;
                
                // Normalizar e escalar o vetor
                const scale = Math.min(20, magnitude / 500);
                const dx = field.Ex / magnitude * scale;
                const dy = field.Ey / magnitude * scale;
                
                // Desenhar o vetor
                vectorFieldCtx.beginPath();
                vectorFieldCtx.moveTo(x, y);
                vectorFieldCtx.lineTo(x + dx, y + dy);
                vectorFieldCtx.stroke();
                
                // Desenhar a ponta da seta
                const angle = Math.atan2(dy, dx);
                const headLength = 8;
                const headAngle = Math.PI / 6;
                
                vectorFieldCtx.beginPath();
                vectorFieldCtx.moveTo(x + dx, y + dy);
                vectorFieldCtx.lineTo(
                    x + dx - headLength * Math.cos(angle - headAngle),
                    y + dy - headLength * Math.sin(angle - headAngle)
                );
                vectorFieldCtx.lineTo(
                    x + dx - headLength * Math.cos(angle + headAngle),
                    y + dy - headLength * Math.sin(angle + headAngle)
                );
                vectorFieldCtx.closePath();
                vectorFieldCtx.fill();
            }
        }
        
        // Desenhar as cargas
        for (const charge of chargesVector) {
            vectorFieldCtx.beginPath();
            vectorFieldCtx.arc(charge.x, charge.y, charge.radius, 0, Math.PI * 2);
            
            if (charge.q > 0) {
                vectorFieldCtx.fillStyle = 'red';
            } else if (charge.q < 0) {
                vectorFieldCtx.fillStyle = 'blue';
            } else {
                vectorFieldCtx.fillStyle = 'gray';
            }
            
            vectorFieldCtx.fill();
            vectorFieldCtx.strokeStyle = 'white';
            vectorFieldCtx.lineWidth = 2;
            vectorFieldCtx.stroke();
            
            vectorFieldCtx.fillStyle = 'white';
            vectorFieldCtx.font = 'bold 16px Arial';
            vectorFieldCtx.textAlign = 'center';
            vectorFieldCtx.textBaseline = 'middle';
            
            if (charge.q > 0) {
                vectorFieldCtx.fillText('+', charge.x, charge.y);
            } else if (charge.q < 0) {
                vectorFieldCtx.fillText('-', charge.x, charge.y);
            } else {
                vectorFieldCtx.fillText('0', charge.x, charge.y);
            }
        }
    }
    
    // Event listeners para a aba 3
    charge5Slider.addEventListener('input', () => {
        chargesVector[0].q = parseInt(charge5Slider.value);
        updateVectorChargeValues();
        drawVectorField();
    });
    
    charge6Slider.addEventListener('input', () => {
        chargesVector[1].q = parseInt(charge6Slider.value);
        updateVectorChargeValues();
        drawVectorField();
    });
    
    resetVectorBtn.addEventListener('click', () => {
        chargesVector[0].x = 150;
        chargesVector[0].y = 200;
        chargesVector[1].x = 400;
        chargesVector[1].y = 200;
        chargesVector[0].q = 60;
        chargesVector[1].q = 60;
        charge5Slider.value = 60;
        charge6Slider.value = 60;
        updateVectorChargeValues();
        drawVectorField();
    });
    
    infoVectorBtn.addEventListener('click', () => {
        showAvatarMessage("A representa√ß√£o vetorial do campo el√©trico mostra claramente a dire√ß√£o e intensidade em cada ponto do espa√ßo!", 2, 5000);
    });
    
    // ========== ABA 4: CAMPO MAGN√âTICO ==========
    const magneticCanvas = document.getElementById('magneticCanvas');
    const magneticCtx = magneticCanvas.getContext('2d');
    
    const currentSlider = document.getElementById('current');
    const currentValue = document.getElementById('currentValue');
    const intoPageBtn = document.getElementById('intoPageBtn');
    const outPageBtn = document.getElementById('outPageBtn');
    const infoMagBtn = document.getElementById('infoMagBtn');
    
    let current = parseFloat(currentSlider.value) || 10;
    let direction = 1; // 1 = saindo (‚äô), -1 = entrando (‚äó)
    const mu0 = 4 * Math.PI * 1e-7;
    
    // --- anima√ß√£o ---
    let animationOffset = 0;
    let lastTimestamp = null;
    let animateMagnetic = true;
    
    function updateCurrentDisplay() {
        // mostra sinal e valor claramente
        const sign = direction > 0 ? '+' : '-';
        currentValue.textContent = `${sign}${current.toFixed(1)} A`;
        currentValue.className = `charge-value ${direction > 0 ? 'positive' : 'negative'}`;
    }
    
    // nova fun√ß√£o de desenho com setas tangenciais e movimento
    function drawMagneticField(timestamp) {
        if (!lastTimestamp) lastTimestamp = timestamp || performance.now();
        const now = timestamp || performance.now();
        const dt = (now - lastTimestamp) / 1000; // segundos
        lastTimestamp = now;
    
        // atualizar offset da anima√ß√£o proporcional √† corrente
        // usar valor absoluto: maior corrente => setas mais r√°pidas
        animationOffset -= direction * current * dt * 15; // controle de velocidade (ajust√°vel)
    
        magneticCtx.clearRect(0, 0, magneticCanvas.width, magneticCanvas.height);
        const cx = magneticCanvas.width / 2;
        const cy = magneticCanvas.height / 2;
    
        // fundo
        const gradient = magneticCtx.createRadialGradient(cx, cy, 50, cx, cy, 300);
        gradient.addColorStop(0, 'rgba(10, 20, 40, 0.8)');
        gradient.addColorStop(1, 'rgba(5, 10, 20, 0.9)');
        magneticCtx.fillStyle = gradient;
        magneticCtx.fillRect(0, 0, magneticCanvas.width, magneticCanvas.height);
    
        // fio central
        magneticCtx.beginPath();
        magneticCtx.arc(cx, cy, 15, 0, 2 * Math.PI);
        magneticCtx.fillStyle = '#ff9900';
        magneticCtx.fill();
        magneticCtx.strokeStyle = 'white';
        magneticCtx.lineWidth = 2;
        magneticCtx.stroke();
        magneticCtx.fillStyle = 'white';
        magneticCtx.font = 'bold 26px Arial';
        magneticCtx.textAlign = 'center';
        magneticCtx.textBaseline = 'middle';
        magneticCtx.fillText(direction > 0 ? '‚äô' : '‚äó', cx, cy);
    
        // c√≠rculos do campo
        magneticCtx.strokeStyle = '#00ff00';
        magneticCtx.lineWidth = 2;
    
        // par√¢metros
        const minR = 40;
        const maxR = 180;
        const stepR = 30;
        const arrowSpacing = 40; // espa√ßo entre setas ao longo do arco
        const arrowSize = 8;
    
        for (let r = minR; r <= maxR; r += stepR) {
            magneticCtx.beginPath();
            magneticCtx.arc(cx, cy, r, 0, 2 * Math.PI);
            magneticCtx.stroke();
    
            // desenhar setas ao longo do c√≠rculo
            // o n√∫mero de posi√ß√µes depende do per√≠metro e arrowSpacing
            const circumference = 2 * Math.PI * r;
            const numPositions = Math.max(6, Math.floor(circumference / arrowSpacing));
            for (let i = 0; i < numPositions; i++) {
                // par√¢metro t em [0,1)
                // adicionar animationOffset para deslocamento (movimento)
                const t = (i / numPositions + (animationOffset / circumference)) % 1;
                const angle = t * 2 * Math.PI;
    
                // posi√ß√£o da seta
                const x = cx + r * Math.cos(angle);
                const y = cy + r * Math.sin(angle);
    
                // tangente ao c√≠rculo -> dire√ß√£o do campo (90¬∞ da radial)
                // para campo anticlockwise (direction>0) a seta aponta tangentemente
                const tangentAngle = angle + (direction > 0 ? -Math.PI / 2 : Math.PI / 2);
    
                // desenhar tri√¢ngulo orientado para tangentAngle
                magneticCtx.save();
                magneticCtx.translate(x, y);
                magneticCtx.rotate(tangentAngle);
    
                magneticCtx.beginPath();
                // tri√¢ngulo apontando para a direita no sistema local
                magneticCtx.moveTo(0, 0);
                magneticCtx.lineTo(-arrowSize, -arrowSize / 2);
                magneticCtx.lineTo(-arrowSize, arrowSize / 2);
                magneticCtx.closePath();
                magneticCtx.fillStyle = '#00ff00';
                magneticCtx.fill();
                magneticCtx.restore();
            }
        }
    
        // continuar anima√ß√£o se habilitado
        if (animateMagnetic) {
            requestAnimationFrame(drawMagneticField);
        }
    }
    
    // listeners atualizados
    currentSlider.addEventListener('input', () => {
        current = parseFloat(currentSlider.value);
        updateCurrentDisplay();
        // a velocidade da anima√ß√£o mudar√° automaticamente (n√≥s j√° usamos current no c√°lculo)
    });
    
    intoPageBtn.addEventListener('click', () => {
        direction = -1;
        updateCurrentDisplay();
    });
    
    outPageBtn.addEventListener('click', () => {
        direction = 1;
        updateCurrentDisplay();
    });
    
    infoMagBtn.addEventListener('click', () => {
        showAvatarMessage("O campo magn√©tico de um fio √© circular. Use a regra da m√£o direita para descobrir seu sentido!", 3, 6000);
    });
    
    // ========== INICIALIZA√á√ÉO ==========
    updateFieldChargeValues();
    drawFieldLines();
    
    initializeElectrodes();
    drawTank();
    
    updateVectorChargeValues();
    drawVectorField();
    
    updateCurrentDisplay();
    animateMagnetic = true;
    lastTimestamp = null;
    requestAnimationFrame(drawMagneticField);
    
    // Inicia a explica√ß√£o autom√°tica na aba ativa
    startFieldExplanation();
    
    // Adicionar event listeners de arrastar para as outras abas
    function setupDragAndDrop(canvas, charges, drawFunction) {
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            for (const charge of charges) {
                const dx = mouseX - charge.x;
                const dy = mouseY - charge.y;
                if (dx * dx + dy * dy <= charge.radius * charge.radius) {
                    charge.dragging = true;
                    canvas.style.cursor = 'grabbing';
                    break;
                }
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            let overCharge = false;
            for (const charge of charges) {
                if (charge.dragging) {
                    charge.x = mouseX;
                    charge.y = mouseY;
                    drawFunction();
                } else {
                    const dx = mouseX - charge.x;
                    const dy = mouseY - charge.y;
                    if (dx * dx + dy * dy <= charge.radius * charge.radius) {
                        overCharge = true;
                    }
                }
            }
            
            canvas.style.cursor = overCharge ? 'grab' : 'default';
        });
        
        canvas.addEventListener('mouseup', () => {
            for (const charge of charges) {
                charge.dragging = false;
            }
            canvas.style.cursor = 'default';
        });
    }
    
    setupDragAndDrop(vectorFieldCanvas, chargesVector, drawVectorField);
    
    // Verificar se a s√≠ntese de voz est√° dispon√≠vel
    if (!speechSupported) {
        console.warn("A s√≠ntese de voz n√£o √© suportada neste navegador. A funcionalidade de voz n√£o estar√° dispon√≠vel.");
        
        // Desativar bot√µes de voz
        document.querySelectorAll('.avatar-controls button').forEach(btn => {
            btn.disabled = true;
            btn.textContent = "Voz n√£o suportada";
        });
    }
</script>
</body>
</html>