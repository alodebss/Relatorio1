<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Simulações de Campo Elétrico</title>
<style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
            max-width: 800px;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .subtitle {
            font-size: 1.2rem;
            margin-bottom: 20px;
            opacity: 0.9;
        }
        
        .tabs {
            display: flex;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 10px 10px 0 0;
            overflow: hidden;
            margin-bottom: 0;
            width: 100%;
            max-width: 1200px;
        }
        
        .tab {
            padding: 15px 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            flex: 1;
            font-weight: bold;
        }
        
        .tab:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        
        .tab.active {
            background-color: rgba(255, 255, 255, 0.9);
            color: #1a2a6c;
        }
        
        .container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 30px;
            max-width: 1200px;
            width: 100%;
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 0 0 15px 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }
        
        .tab-content {
            display: none;
            width: 100%;
        }
        
        .tab-content.active {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
        }
        
        .simulation-panel {
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            border-radius: 15px;
            padding: 20px;
            flex: 1;
            min-width: 300px;
            max-width: 600px;
        }
        
        .explanation-panel {
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            border-radius: 15px;
            padding: 20px;
            flex: 1;
            min-width: 300px;
            max-width: 500px;
            display: flex;
            flex-direction: column;
        }
        
        canvas {
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            display: block;
            margin: 0 auto;
            cursor: grab;
        }
        
        .controls {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .charge-control {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        input[type="range"] {
            flex: 1;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
        }
        
        .charge-value {
            min-width: 70px;
            font-weight: bold;
            text-align: center;
            padding: 5px;
            border-radius: 5px;
        }
        
        .positive {
            background-color: rgba(255, 0, 0, 0.3);
        }
        
        .negative {
            background-color: rgba(0, 0, 255, 0.3);
        }
        
        .buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            background-color: #4a00e0;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 1;
        }
        
        button:hover {
            background-color: #8e2de2;
            transform: translateY(-2px);
        }
        
        .avatar-container {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .avatar {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, #8e2de2, #4a00e0);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 15px;
            font-size: 2rem;
            position: relative;
            animation: avatar-bounce 3s infinite ease-in-out;
        }
        
        .avatar::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.4) 0%, transparent 70%);
        }
        
        .speech-bubble {
            background-color: rgba(255, 255, 255, 0.9);
            color: #333;
            padding: 15px;
            border-radius: 20px;
            position: relative;
            flex: 1;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.5s ease;
            min-height: 80px;
            display: flex;
            align-items: center;
        }
        
        .speech-bubble.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .speech-bubble:after {
            content: '';
            position: absolute;
            left: -10px;
            top: 30px;
            width: 0;
            height: 0;
            border: 10px solid transparent;
            border-right-color: rgba(255, 255, 255, 0.9);
        }
        
        .explanation-content {
            background-color: rgba(255, 255, 255, 0.9);
            color: #333;
            padding: 20px;
            border-radius: 10px;
            flex: 1;
            overflow-y: auto;
            max-height: 300px;
        }
        
        .explanation-content h3 {
            margin-bottom: 15px;
            color: #4a00e0;
        }
        
        .explanation-content p {
            margin-bottom: 15px;
            line-height: 1.5;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }
        
        .positive-color {
            background-color: red;
        }
        
        .negative-color {
            background-color: blue;
        }
        
        .field-color {
            background-color: #00ff00;
        }
        
        .equipotential-color {
            background-color: #ff00ff;
        }
        
        .electrode-color {
            background-color: #ff9900;
        }
        
        .instructions {
            margin-top: 20px;
            text-align: center;
            font-style: italic;
            opacity: 0.8;
        }
        
        .electrode-controls {
            display: flex;
            gap: 15px;
            margin-top: 15px;
        }
        
        .electrode-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
        }
        
        .visualization-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .vis-checkbox {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .avatar-controls {
            display: flex;
            justify-content: center;
            margin-top: 10px;
            gap: 10px;
        }
        
        .avatar-controls button {
            padding: 8px 12px;
            font-size: 0.9rem;
        }
        
        @keyframes avatar-bounce {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-5px);
            }
        }
        
        @keyframes avatar-talk {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }
        
        .avatar.talking {
            animation: avatar-bounce 3s infinite ease-in-out, avatar-talk 0.5s infinite alternate;
        }
        
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .simulation-panel, .explanation-panel {
                max-width: 100%;
            }
            
            .tabs {
                flex-direction: column;
            }
            
            .electrode-controls {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
<div class="header">
<h1>Simulações de Campo Elétrico</h1>
<p class="subtitle">Explore diferentes aspectos dos campos elétricos através de simulações interativas</p>
</div>
<div class="tabs">
<div class="tab active" data-tab="field-lines">Linhas de Campo</div>
<div class="tab" data-tab="electrolytic-tank">Cuba Eletrolítica</div>
<div class="tab" data-tab="electric-field">Campo Elétrico</div>
<div class="tab" data-tab="magnetic-field">Campo Magnético</div></div>
<div class="container">
<!-- Aba 1: Linhas de Campo entre Cargas Pontuais -->
<div class="tab-content active" id="field-lines">
<div class="simulation-panel">
<canvas height="400" id="fieldCanvas" width="550"></canvas>
<div class="controls">
<div class="charge-control">
<label for="charge1">Carga 1:</label>
<div class="slider-container">
<input id="charge1" max="100" min="-100" type="range" value="50"/>
<span class="charge-value positive" id="charge1Value">+50 μC</span>
</div>
</div>
<div class="charge-control">
<label for="charge2">Carga 2:</label>
<div class="slider-container">
<input id="charge2" max="100" min="-100" type="range" value="-50"/>
<span class="charge-value negative" id="charge2Value">-50 μC</span>
</div>
</div>
<div class="buttons">
<button id="resetBtn">Resetar Posições</button>
<button id="infoBtn">Mais Informações</button>
</div>
</div>
<div class="legend">
<div class="legend-item">
<div class="legend-color positive-color"></div>
<span>Carga Positiva</span>
</div>
<div class="legend-item">
<div class="legend-color negative-color"></div>
<span>Carga Negativa</span>
</div>
<div class="legend-item">
<div class="legend-color field-color"></div>
<span>Linhas de Campo</span>
</div>
</div>
<p class="instructions">Arraste as cargas para movê-las. Use os controles para alterar seus valores.</p>
</div>
<div class="explanation-panel">
<div class="avatar-container">
<div class="avatar">👩‍🔬</div>
<div class="speech-bubble" id="avatarSpeech1">
                        Olá! Esta simulação mostra as linhas de campo elétrico entre duas cargas pontuais.
                    </div>
</div>
<div class="avatar-controls">
<button id="playBtn1">▶️ Reproduzir Explicação</button>
<button id="pauseBtn1">⏸️ Pausar</button>
</div>
<div class="explanation-content">
<h3>Linhas de Campo Elétrico</h3>
<p>As linhas de campo elétrico são uma representação visual que mostra a direção e intensidade do campo elétrico em cada ponto do espaço.</p>
<p><strong>Características das linhas de campo:</strong></p>
<ul>
<li>Saem das cargas positivas e entram nas cargas negativas</li>
<li>A densidade das linhas é proporcional à intensidade do campo</li>
<li>Nunca se cruzam</li>
<li>São perpendiculares às superfícies condutoras</li>
</ul>
<p><strong>Como interpretar:</strong></p>
<p>Onde as linhas estão mais próximas, o campo elétrico é mais intenso. O sentido das setas indica a direção que uma carga positiva seguiria se colocada naquele ponto.</p>
</div>
</div>
</div>
<!-- Aba 2: Cuba Eletrolítica com Placas Paralelas -->
<div class="tab-content" id="electrolytic-tank">
<div class="simulation-panel">
<canvas height="400" id="tankCanvas" width="550"></canvas>
<div class="controls">
<div class="electrode-controls">
<div class="electrode-control">
<label for="plateDistance">Distância entre Placas:</label>
<input id="plateDistance" max="300" min="100" type="range" value="200"/>
<span id="plateDistanceValue">200 px</span>
</div>
<div class="electrode-control">
<label for="plateHeight">Altura das Placas:</label>
<input id="plateHeight" max="200" min="80" type="range" value="160"/>
<span id="plateHeightValue">160 px</span>
</div>
</div>
<div class="electrode-controls">
<div class="electrode-control">
<label for="voltage">Tensão (V):</label>
<input id="voltage" max="20" min="1" type="range" value="12"/>
<span id="voltageValue">12 V</span>
</div>
</div>
<div class="visualization-controls">
<div class="vis-checkbox">
<input checked="" id="showFieldLines" type="checkbox"/>
<label for="showFieldLines">Mostrar Linhas de Campo</label>
</div>
<div class="vis-checkbox">
<input checked="" id="showEquipotentials" type="checkbox"/>
<label for="showEquipotentials">Mostrar Equipotenciais</label>
</div>
</div>
<div class="buttons">
<button id="infoTankBtn">Mais Informações</button>
</div>
</div>
<div class="legend">
<div class="legend-item">
<div class="legend-color electrode-color"></div>
<span>Eletrodos</span>
</div>
<div class="legend-item">
<div class="legend-color field-color"></div>
<span>Linhas de Campo</span>
</div>
<div class="legend-item">
<div class="legend-color equipotential-color"></div>
<span>Linhas Equipotenciais</span>
</div>
</div>
<p class="instructions">Ajuste a distância entre as placas, altura das placas e a tensão aplicada.</p>
</div>
<div class="explanation-panel">
<div class="avatar-container">
<div class="avatar">👩‍🔬</div>
<div class="speech-bubble" id="avatarSpeech2">
                        Esta é uma simulação do experimento da cuba eletrolítica com placas paralelas.
                    </div>
</div>
<div class="avatar-controls">
<button id="playBtn2">▶️ Reproduzir Explicação</button>
<button id="pauseBtn2">⏸️ Pausar</button>
</div>
<div class="explanation-content">
<h3>Cuba Eletrolítica - Placas Paralelas</h3>
<p>O experimento da cuba eletrolítica é um método clássico para visualizar linhas equipotenciais e campos elétricos em duas dimensões.</p>
<p><strong>Placas Paralelas:</strong></p>
<ul>
<li>Criam um campo elétrico quase uniforme entre as placas</li>
<li>As linhas de campo são retas e paralelas</li>
<li>As linhas equipotenciais são perpendiculares às linhas de campo</li>
<li>O campo é mais intenso quando as placas estão mais próximas</li>
<li>Placas maiores criam uma região de campo uniforme mais extensa</li>
</ul>
<p><strong>Como interpretar:</strong></p>
<p>As linhas verdes mostram a direção do campo elétrico. As linhas roxas conectam pontos com o mesmo potencial elétrico. Note que elas são sempre perpendiculares entre si!</p>
<p><strong>Equações importantes:</strong></p>
<p>Campo elétrico: E = V/d</p>
<p>Onde V é a tensão e d é a distância entre as placas</p>
</div>
</div>
</div>
<!-- Aba 3: Campo Elétrico -->
<div class="tab-content" id="electric-field">
<div class="simulation-panel">
<canvas height="400" id="vectorFieldCanvas" width="550"></canvas>
<div class="controls">
<div class="charge-control">
<label for="charge5">Carga 1:</label>
<div class="slider-container">
<input id="charge5" max="100" min="-100" type="range" value="60"/>
<span class="charge-value positive" id="charge5Value">+60 μC</span>
</div>
</div>
<div class="charge-control">
<label for="charge6">Carga 2:</label>
<div class="slider-container">
<input id="charge6" max="100" min="-100" type="range" value="60"/>
<span class="charge-value positive" id="charge6Value">+60 μC</span>
</div>
</div>
<div class="buttons">
<button id="resetVectorBtn">Resetar Posições</button>
<button id="infoVectorBtn">Mais Informações</button>
</div>
</div>
<div class="legend">
<div class="legend-item">
<div class="legend-color positive-color"></div>
<span>Carga Positiva</span>
</div>
<div class="legend-item">
<div class="legend-color negative-color"></div>
<span>Carga Negativa</span>
</div>
<div class="legend-item">
<div class="legend-color field-color"></div>
<span>Vetores de Campo</span>
</div>
</div>
<p class="instructions">Arraste as cargas para movê-las. Os vetores mostram a direção e magnitude do campo.</p>
</div>
<div class="explanation-panel">
<div class="avatar-container">
<div class="avatar">👩‍🔬</div>
<div class="speech-bubble" id="avatarSpeech3">
                        Aqui você vê uma representação vetorial do campo elétrico. Cada vetor mostra direção e intensidade.
                    </div>
</div>
<div class="avatar-controls">
<button id="playBtn3">▶️ Reproduzir Explicação</button>
<button id="pauseBtn3">⏸️ Pausar</button>
</div>
<div class="explanation-content">
<h3>Campo Elétrico Vetorial</h3>
<p>O campo elétrico é uma grandeza vetorial, possuindo magnitude e direção em cada ponto do espaço.</p>
<p><strong>Características da representação vetorial:</strong></p>
<ul>
<li>Cada vetor mostra a direção que uma carga positiva seguiria</li>
<li>O comprimento do vetor é proporcional à intensidade do campo</li>
<li>Vetores mais longos indicam campos mais intensos</li>
<li>O campo é mais forte próximo às cargas</li>
</ul>
<p><strong>Como interpretar:</strong></p>
<p>Observe como os vetores apontam para longe das cargas positivas e em direção às cargas negativas. Onde os vetores são mais longos e próximos, o campo elétrico é mais intenso.</p>
<p><strong>Fórmula do campo elétrico:</strong></p>
<p>E = k * q / r² (Lei de Coulomb)</p>
</div>
</div>
</div>

<div class="tab-content" id="magnetic-field">
<div class="simulation-panel">
<canvas height="400" id="magneticCanvas" width="550"></canvas>
<div class="controls">
<div class="charge-control">
<label for="current">Corrente (I):</label>
<div class="slider-container">
<input id="current" max="20" min="0" type="range" value="10"/>
<span class="charge-value positive" id="currentValue">+10 A</span>
</div>
</div>
<div class="charge-control">
<label>Sentido da Corrente:</label>
<div class="buttons">
<button id="intoPageBtn">⊗ Para dentro da tela</button>
<button id="outPageBtn">⊙ Para fora da tela</button>
</div>
</div>
<div class="buttons">
<button id="infoMagBtn">Mais Informações</button>
</div>
</div>
<div class="legend">
<div class="legend-item">
<div class="legend-color field-color"></div>
<span>Linhas de Campo Magnético</span>
</div>
</div>
<p class="instructions">Use os controles para alterar a corrente e o sentido. Observe o sentido das linhas conforme a regra da mão direita.</p>
</div>
<div class="explanation-panel">
<div class="avatar-container">
<div class="avatar">👩‍🔬</div>
<div class="speech-bubble" id="avatarSpeech4">
                O campo magnético gerado por um fio retilíneo é circular e depende do sentido da corrente.
            </div>
</div>
<div class="avatar-controls">
<button id="playBtn4">▶️ Reproduzir Explicação</button>
<button id="pauseBtn4">⏸️ Pausar</button>
</div>
<div class="explanation-content">
<h3>Campo Magnético ao Redor de um Fio Retilíneo</h3>
<p>Quando uma corrente elétrica percorre um fio, forma-se um campo magnético ao seu redor. As linhas de campo são circulares e concêntricas ao fio.</p>
<p><strong>Sentido do campo:</strong></p>
<ul>
<li>Use a <em>regra da mão direita</em> — o polegar indica o sentido da corrente, e os dedos mostram o sentido do campo magnético.</li>
<li>Corrente <strong>saindo da tela (⊙)</strong> → campo anti-horário.</li>
<li>Corrente <strong>entrando da tela (⊗)</strong> → campo horário.</li>
</ul>
<p><strong>Intensidade do campo:</strong></p>
<p>O campo magnético é dado por:</p>
<p><code>B = μ₀ I / (2πr)</code></p>
<p>onde <code>μ₀</code> é a permeabilidade do vácuo, <code>I</code> a corrente e <code>r</code> a distância ao fio.</p>
</div>
</div>
</div>
</div>
<script>
    // ========== SISTEMA DE VOZ FEMININA ==========
    
    // Verificar suporte à API de síntese de voz
    const speechSupported = 'speechSynthesis' in window;
    
    // Instância da síntese de voz
    let currentSpeech = null;
    let femaleVoice = null;
    
    // Função para encontrar uma voz feminina
    function findFemaleVoice() {
        if (!speechSupported) return null;
        
        const voices = speechSynthesis.getVoices();
        
        // Procurar por vozes femininas em português
        const femaleVoices = voices.filter(voice => {
            // Verificar se a voz é feminina (baseado no nome ou idioma)
            const voiceName = voice.name.toLowerCase();
            return (
                voice.lang.startsWith('pt') && 
                (voiceName.includes('feminina') || 
                 voiceName.includes('female') || 
                 voiceName.includes('mulher') ||
                 voiceName.includes('woman') ||
                 voiceName.includes('ana') ||
                 voiceName.includes('maria') ||
                 voiceName.includes('lucia'))
            );
        });
        
        // Se não encontrar uma voz explicitamente feminina, usar a primeira voz em português
        if (femaleVoices.length > 0) {
            return femaleVoices[0];
        } else {
            const portugueseVoices = voices.filter(voice => voice.lang.startsWith('pt'));
            return portugueseVoices.length > 0 ? portugueseVoices[0] : null;
        }
    }
    
    // Inicializar a voz quando as vozes estiverem carregadas
    function initializeVoice() {
        if (!speechSupported) return;
        
        // Tentar encontrar uma voz feminina
        femaleVoice = findFemaleVoice();
        
        // Se não encontrou, tentar novamente após um tempo (as vozes podem carregar assincronamente)
        if (!femaleVoice) {
            setTimeout(() => {
                femaleVoice = findFemaleVoice();
                console.log("Voz feminina carregada:", femaleVoice ? femaleVoice.name : "Não encontrada");
            }, 1000);
        } else {
            console.log("Voz feminina selecionada:", femaleVoice.name);
        }
    }
    
    // Carregar vozes quando estiverem disponíveis
    if (speechSupported) {
        if (speechSynthesis.getVoices().length > 0) {
            initializeVoice();
        } else {
            speechSynthesis.addEventListener('voiceschanged', initializeVoice);
        }
    }
    
    // Função para falar texto com voz feminina
    function speakText(text, rate = 0.9, pitch = 1.1, volume = 1.0) {
        // Parar qualquer fala anterior
        stopSpeech();
        
        if (!speechSupported) {
            console.log("Síntese de voz não suportada neste navegador");
            return;
        }
        
        // Criar nova instância de fala
        const utterance = new SpeechSynthesisUtterance(text);
        
        // Configurar parâmetros para voz feminina
        utterance.rate = rate;      // Velocidade um pouco mais lenta
        utterance.pitch = pitch;    // Tom mais agudo (feminino)
        utterance.volume = volume;
        utterance.lang = 'pt-BR';
        
        // Usar voz feminina se disponível
        if (femaleVoice) {
            utterance.voice = femaleVoice;
        }
        
        // Evento quando a fala termina
        utterance.onend = function() {
            currentSpeech = null;
        };
        
        // Evento em caso de erro
        utterance.onerror = function(event) {
            console.error("Erro na síntese de voz:", event);
            currentSpeech = null;
        };
        
        // Iniciar fala
        speechSynthesis.speak(utterance);
        currentSpeech = utterance;
    }
    
    // Função para parar a fala
    function stopSpeech() {
        if (speechSupported && speechSynthesis.speaking) {
            speechSynthesis.cancel();
            currentSpeech = null;
        }
    }
    
    // ========== SISTEMA DE ABAS ==========
    
    // Variáveis para controlar os intervalos de explicação
    let fieldExplanationInterval;
    let tankExplanationInterval;
    let vectorExplanationInterval;
    let magneticExplanationInterval;
    
    // Variáveis para controlar os timeouts das mensagens
    let fieldMessageTimeout;
    let tankMessageTimeout;
    let vectorMessageTimeout;
    let magneticMessageTimeout;
    
    // Função para parar TODAS as explicações
    function stopAllExplanations() {
        // Parar todos os intervalos
        clearInterval(fieldExplanationInterval);
        clearInterval(tankExplanationInterval);
        clearInterval(vectorExplanationInterval);
        clearInterval(magneticExplanationInterval);
        
        // Parar todos os timeouts
        clearTimeout(fieldMessageTimeout);
        clearTimeout(tankMessageTimeout);
        clearTimeout(vectorMessageTimeout);
        clearTimeout(magneticMessageTimeout);
        
        // Parar a voz
        stopSpeech();
        
        // Remover animações dos avatares
        document.querySelectorAll('.avatar').forEach(avatar => {
            avatar.classList.remove('talking');
        });
        
        // Esconder bolhas de fala
        document.querySelectorAll('.speech-bubble').forEach(bubble => {
            bubble.classList.remove('show');
        });
    }
    
    document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
            // Parar TODAS as explicações anteriores
            stopAllExplanations();
            
            // Remove a classe active de todas as abas e conteúdos
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            
            // Adiciona a classe active à aba clicada e ao conteúdo correspondente
            tab.classList.add('active');
            const tabId = tab.getAttribute('data-tab');
            document.getElementById(tabId).classList.add('active');
            
            // Inicia a explicação automática quando mudar de aba
            if (tabId === 'field-lines') {
                startFieldExplanation();
            } else if (tabId === 'electrolytic-tank') {
                startTankExplanation();
            } else if (tabId === 'electric-field') {
                startVectorExplanation();
            } else if (tabId === 'magnetic-field') {
                startMagneticExplanation();
            }
        });
    });
    
    // ========== ANIMAÇÃO DO AVATAR ==========
    
    // Elementos do avatar
    const avatars = document.querySelectorAll('.avatar');
    const speechBubbles = document.querySelectorAll('.speech-bubble');
    
    // Função para mostrar uma mensagem no avatar
    function showAvatarMessage(message, avatarIndex, duration = 5000) {
        const avatar = avatars[avatarIndex];
        const speechBubble = speechBubbles[avatarIndex];
        
        // Adiciona animação de fala
        avatar.classList.add('talking');
        
        // Mostra a bolha de fala
        speechBubble.textContent = message;
        speechBubble.classList.add('show');
        
        // Falar o texto com voz feminina
        speakText(message);
        
        // Remove a animação após um tempo
        setTimeout(() => {
            avatar.classList.remove('talking');
        }, duration - 1000);
        
        // Esconde a bolha de fala após o tempo especificado
        setTimeout(() => {
            speechBubble.classList.remove('show');
        }, duration);
    }
    
    // ========== SISTEMA DE EXPLICAÇÃO AUTOMÁTICA ==========
    
    // Aba 1: Linhas de Campo
    const fieldMessages = [
        "Olá! Esta simulação mostra as linhas de campo elétrico entre duas cargas pontuais.",
        "As linhas de campo elétrico mostram a direção do campo em cada ponto do espaço.",
        "Elas saem das cargas positivas e entram nas cargas negativas.",
        "A densidade das linhas é proporcional à intensidade do campo elétrico.",
        "Onde as linhas estão mais próximas, o campo é mais forte!",
        "As linhas de campo nunca se cruzam. Isso é uma propriedade importante!",
        "Experimente alterar os valores das cargas para ver como o campo muda."
    ];
    
    function startFieldExplanation() {
        // Limpar qualquer explicação anterior
        clearInterval(fieldExplanationInterval);
        clearTimeout(fieldMessageTimeout);
        
        let messageIndex = 0;
        
        // Mostra a primeira mensagem imediatamente
        showAvatarMessage(fieldMessages[messageIndex], 0, 6000);
        messageIndex++;
        
        // Configura o intervalo para as próximas mensagens
        fieldExplanationInterval = setInterval(() => {
            if (messageIndex < fieldMessages.length) {
                showAvatarMessage(fieldMessages[messageIndex], 0, 6000);
                messageIndex++;
            } else {
                // Reinicia o ciclo
                messageIndex = 0;
                showAvatarMessage(fieldMessages[messageIndex], 0, 6000);
                messageIndex++;
            }
        }, 7000);
    }
    
    // Aba 2: Cuba Eletrolítica
    const tankMessages = [
        "Esta é uma simulação do experimento da cuba eletrolítica com placas paralelas.",
        "A cuba eletrolítica é usada para visualizar campos elétricos em 2D.",
        "As placas paralelas criam um campo elétrico quase uniforme entre elas.",
        "As linhas verdes mostram a direção do campo elétrico.",
        "As linhas roxas são equipotenciais - pontos com o mesmo potencial.",
        "Note que as linhas de campo e equipotenciais são sempre perpendiculares!",
        "O campo elétrico é calculado por E = V/d, onde V é a tensão e d é a distância.",
        "Experimente alterar a distância entre as placas para ver como o campo muda."
    ];
    
    function startTankExplanation() {
        // Limpar qualquer explicação anterior
        clearInterval(tankExplanationInterval);
        clearTimeout(tankMessageTimeout);
        
        let messageIndex = 0;
        
        // Mostra a primeira mensagem imediatamente
        showAvatarMessage(tankMessages[messageIndex], 1, 6000);
        messageIndex++;
        
        // Configura o intervalo para as próximas mensagens
        tankExplanationInterval = setInterval(() => {
            if (messageIndex < tankMessages.length) {
                showAvatarMessage(tankMessages[messageIndex], 1, 6000);
                messageIndex++;
            } else {
                // Reinicia o ciclo
                messageIndex = 0;
                showAvatarMessage(tankMessages[messageIndex], 1, 6000);
                messageIndex++;
            }
        }, 7000);
    }
    
    // Aba 3: Campo Elétrico Vetorial
    const vectorMessages = [
        "Aqui você vê uma representação vetorial do campo elétrico.",
        "Cada vetor mostra a direção e intensidade do campo em um ponto.",
        "Vetores mais longos indicam campos mais intensos.",
        "Os vetores apontam para longe das cargas positivas.",
        "E apontam em direção às cargas negativas.",
        "O campo é mais forte próximo às cargas, onde os vetores são maiores.",
        "A fórmula do campo é E = k * q / r² (Lei de Coulomb).",
        "Experimente mover as cargas para ver como os vetores mudam."
    ];
    
    function startVectorExplanation() {
        // Limpar qualquer explicação anterior
        clearInterval(vectorExplanationInterval);
        clearTimeout(vectorMessageTimeout);
        
        let messageIndex = 0;
        
        // Mostra a primeira mensagem imediatamente
        showAvatarMessage(vectorMessages[messageIndex], 2, 6000);
        messageIndex++;
        
        // Configura o intervalo para as próximas mensagens
        vectorExplanationInterval = setInterval(() => {
            if (messageIndex < vectorMessages.length) {
                showAvatarMessage(vectorMessages[messageIndex], 2, 6000);
                messageIndex++;
            } else {
                // Reinicia o ciclo
                messageIndex = 0;
                showAvatarMessage(vectorMessages[messageIndex], 2, 6000);
                messageIndex++;
            }
        }, 7000);
    }
    
    // Aba 4: Campo Magnético
    const magneticMessages = [
        "Aqui temos o campo magnético gerado por um fio percorrido por corrente elétrica.",
        "As linhas são circulares e concêntricas ao fio.",
        "O sentido do campo é determinado pela regra da mão direita.",
        "Corrente saindo da tela: campo anti-horário.",
        "Corrente entrando da tela: campo horário.",
        "A intensidade do campo é B = μ₀ vezes I dividido por 2πr.",
        "Experimente mudar o sentido da corrente e veja o campo girar!"
    ];
    
    function startMagneticExplanation() {
        // Limpar qualquer explicação anterior
        clearInterval(magneticExplanationInterval);
        clearTimeout(magneticMessageTimeout);
        
        let messageIndex = 0;
        
        // Mostra a primeira mensagem imediatamente
        showAvatarMessage(magneticMessages[messageIndex], 3, 6000);
        messageIndex++;
        
        // Configura o intervalo para as próximas mensagens
        magneticExplanationInterval = setInterval(() => {
            if (messageIndex < magneticMessages.length) {
                showAvatarMessage(magneticMessages[messageIndex], 3, 6000);
                messageIndex++;
            } else {
                // Reinicia o ciclo
                messageIndex = 0;
                showAvatarMessage(magneticMessages[messageIndex], 3, 6000);
                messageIndex++;
            }
        }, 7000);
    }
    
    // Controles de reprodução para cada aba
    document.getElementById('playBtn1').addEventListener('click', startFieldExplanation);
    document.getElementById('pauseBtn1').addEventListener('click', () => {
        clearInterval(fieldExplanationInterval);
        clearTimeout(fieldMessageTimeout);
        avatars[0].classList.remove('talking');
        speechBubbles[0].classList.remove('show');
        stopSpeech();
    });
    
    document.getElementById('playBtn2').addEventListener('click', startTankExplanation);
    document.getElementById('pauseBtn2').addEventListener('click', () => {
        clearInterval(tankExplanationInterval);
        clearTimeout(tankMessageTimeout);
        avatars[1].classList.remove('talking');
        speechBubbles[1].classList.remove('show');
        stopSpeech();
    });
    
    document.getElementById('playBtn3').addEventListener('click', startVectorExplanation);
    document.getElementById('pauseBtn3').addEventListener('click', () => {
        clearInterval(vectorExplanationInterval);
        clearTimeout(vectorMessageTimeout);
        avatars[2].classList.remove('talking');
        speechBubbles[2].classList.remove('show');
        stopSpeech();
    });
    
    document.getElementById('playBtn4').addEventListener('click', startMagneticExplanation);
    document.getElementById('pauseBtn4').addEventListener('click', () => {
        clearInterval(magneticExplanationInterval);
        clearTimeout(magneticMessageTimeout);
        avatars[3].classList.remove('talking');
        speechBubbles[3].classList.remove('show');
        stopSpeech();
    });
    
    // ========== ABA 1: LINHAS DE CAMPO ==========
    const fieldCanvas = document.getElementById('fieldCanvas');
    const fieldCtx = fieldCanvas.getContext('2d');
    
    // Elementos de controle da aba 1
    const charge1Slider = document.getElementById('charge1');
    const charge2Slider = document.getElementById('charge2');
    const charge1Value = document.getElementById('charge1Value');
    const charge2Value = document.getElementById('charge2Value');
    const resetBtn = document.getElementById('resetBtn');
    const infoBtn = document.getElementById('infoBtn');
    
    // Estado das cargas da aba 1
    let chargesField = [
        { x: 150, y: 200, q: 50, radius: 20, dragging: false },
        { x: 400, y: 200, q: -50, radius: 20, dragging: false }
    ];
    
    // Constante de proporcionalidade
    const k = 100000;
    
    // Atualizar os valores das cargas nos controles da aba 1
    function updateFieldChargeValues() {
        const charge1Sign = chargesField[0].q > 0 ? '+' : '';
        const charge2Sign = chargesField[1].q > 0 ? '+' : '';
        
        charge1Value.textContent = `${charge1Sign}${chargesField[0].q} μC`;
        charge2Value.textContent = `${charge2Sign}${chargesField[1].q} μC`;
        
        charge1Value.className = `charge-value ${chargesField[0].q > 0 ? 'positive' : 'negative'}`;
        charge2Value.className = `charge-value ${chargesField[1].q > 0 ? 'positive' : 'negative'}`;
    }
    
    // Calcular o campo elétrico em um ponto (x, y) na aba 1
    function calculateField(x, y, charges) {
        let Ex = 0, Ey = 0;
        
        for (const charge of charges) {
            const dx = x - charge.x;
            const dy = y - charge.y;
            const rSquared = dx * dx + dy * dy;
            
            if (rSquared < 1) continue;
            
            const r = Math.sqrt(rSquared);
            const E = k * charge.q / rSquared;
            
            Ex += E * dx / r;
            Ey += E * dy / r;
        }
        
        return { Ex, Ey };
    }
    
    // Desenhar uma seta na aba 1
    function drawFieldArrow(x, y, angle, length) {
        const headLength = 10;
        const headAngle = Math.PI / 6;
        
        fieldCtx.beginPath();
        fieldCtx.moveTo(x, y);
        fieldCtx.lineTo(x + length * Math.cos(angle), y + length * Math.sin(angle));
        fieldCtx.stroke();
        
        fieldCtx.beginPath();
        fieldCtx.moveTo(x + length * Math.cos(angle), y + length * Math.sin(angle));
        fieldCtx.lineTo(
            x + length * Math.cos(angle) - headLength * Math.cos(angle - headAngle),
            y + length * Math.sin(angle) - headLength * Math.sin(angle - headAngle)
        );
        fieldCtx.lineTo(
            x + length * Math.cos(angle) - headLength * Math.cos(angle + headAngle),
            y + length * Math.sin(angle) - headLength * Math.sin(angle + headAngle)
        );
        fieldCtx.closePath();
        fieldCtx.fill();
    }
    
    // Desenhar as linhas de campo na aba 1
    function drawFieldLines() {
        const gradient = fieldCtx.createLinearGradient(0, 0, fieldCanvas.width, fieldCanvas.height);
        gradient.addColorStop(0, 'rgba(10, 20, 40, 0.8)');
        gradient.addColorStop(1, 'rgba(5, 10, 20, 0.9)');
        fieldCtx.fillStyle = gradient;
        fieldCtx.fillRect(0, 0, fieldCanvas.width, fieldCanvas.height);
        
        // Desenhar linhas de campo com setas
        fieldCtx.strokeStyle = '#00ff00';
        fieldCtx.fillStyle = '#00ff00';
        fieldCtx.lineWidth = 1.5;
        
        const step = 5;
        const arrowSpacing = 25;
        
        for (const charge of chargesField) {
            const numLines = Math.min(24, Math.abs(charge.q) * 0.4 + 8);
            
            for (let i = 0; i < numLines; i++) {
                const angle = (i / numLines) * Math.PI * 2;
                
                let x, y;
                if (charge.q > 0) {
                    x = charge.x + (charge.radius + 5) * Math.cos(angle);
                    y = charge.y + (charge.radius + 5) * Math.sin(angle);
                } else {
                    x = charge.x + 250 * Math.cos(angle);
                    y = charge.y + 250 * Math.sin(angle);
                }
                
                fieldCtx.beginPath();
                fieldCtx.moveTo(x, y);
                
                let totalLength = 0;
                let steps = 0;
                
                while (steps < 300) {
                    const field = calculateField(x, y, chargesField);
                    const magnitude = Math.sqrt(field.Ex * field.Ex + field.Ey * field.Ey);
                    
                    if (magnitude < 0.1) break;
                    
                    let dx, dy;
                    if (charge.q > 0) {
                        dx = field.Ex / magnitude;
                        dy = field.Ey / magnitude;
                    } else {
                        dx = -field.Ex / magnitude;
                        dy = -field.Ey / magnitude;
                    }
                    
                    x += dx * step;
                    y += dy * step;
                    totalLength += step;
                    
                    if (x < 0 || x > fieldCanvas.width || y < 0 || y > fieldCanvas.height) break;
                    
                    // Desenhar seta periodicamente
                    if (totalLength % arrowSpacing < step) {
                        const arrowAngle = Math.atan2(dy, dx);
                        drawFieldArrow(x, y, arrowAngle, 10);
                    }
                    
                    fieldCtx.lineTo(x, y);
                    
                    let tooClose = false;
                    for (const otherCharge of chargesField) {
                        if (otherCharge === charge) continue;
                        const dist = Math.sqrt((x - otherCharge.x) ** 2 + (y - otherCharge.y) ** 2);
                        if (dist < otherCharge.radius + 5) {
                            tooClose = true;
                            break;
                        }
                    }
                    if (tooClose) break;
                    
                    steps++;
                }
                
                fieldCtx.stroke();
            }
        }
        
        // Desenhar as cargas
        for (const charge of chargesField) {
            fieldCtx.beginPath();
            fieldCtx.arc(charge.x, charge.y, charge.radius, 0, Math.PI * 2);
            
            if (charge.q > 0) {
                fieldCtx.fillStyle = 'red';
            } else if (charge.q < 0) {
                fieldCtx.fillStyle = 'blue';
            } else {
                fieldCtx.fillStyle = 'gray';
            }
            
            fieldCtx.fill();
            fieldCtx.strokeStyle = 'white';
            fieldCtx.lineWidth = 2;
            fieldCtx.stroke();
            
            fieldCtx.fillStyle = 'white';
            fieldCtx.font = 'bold 16px Arial';
            fieldCtx.textAlign = 'center';
            fieldCtx.textBaseline = 'middle';
            
            if (charge.q > 0) {
                fieldCtx.fillText('+', charge.x, charge.y);
            } else if (charge.q < 0) {
                fieldCtx.fillText('-', charge.x, charge.y);
            } else {
                fieldCtx.fillText('0', charge.x, charge.y);
            }
        }
    }
    
    // Event listeners para a aba 1
    charge1Slider.addEventListener('input', () => {
        chargesField[0].q = parseInt(charge1Slider.value);
        updateFieldChargeValues();
        drawFieldLines();
    });
    
    charge2Slider.addEventListener('input', () => {
        chargesField[1].q = parseInt(charge2Slider.value);
        updateFieldChargeValues();
        drawFieldLines();
    });
    
    resetBtn.addEventListener('click', () => {
        chargesField[0].x = 150;
        chargesField[0].y = 200;
        chargesField[1].x = 400;
        chargesField[1].y = 200;
        chargesField[0].q = 50;
        chargesField[1].q = -50;
        charge1Slider.value = 50;
        charge2Slider.value = -50;
        updateFieldChargeValues();
        drawFieldLines();
    });
    
    infoBtn.addEventListener('click', () => {
        showAvatarMessage("As linhas de campo elétrico são uma ferramenta visual poderosa para entender como cargas interagem à distância!", 0, 5000);
    });
    
    // Event listeners para interação com o mouse na aba 1
    fieldCanvas.addEventListener('mousedown', (e) => {
        const rect = fieldCanvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        for (const charge of chargesField) {
            const dx = mouseX - charge.x;
            const dy = mouseY - charge.y;
            if (dx * dx + dy * dy <= charge.radius * charge.radius) {
                charge.dragging = true;
                fieldCanvas.style.cursor = 'grabbing';
                break;
            }
        }
    });
    
    fieldCanvas.addEventListener('mousemove', (e) => {
        const rect = fieldCanvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        let overCharge = false;
        for (const charge of chargesField) {
            if (charge.dragging) {
                charge.x = mouseX;
                charge.y = mouseY;
                drawFieldLines();
            } else if (isMouseOverFieldCharge(mouseX, mouseY, charge)) {
                overCharge = true;
            }
        }
        
        fieldCanvas.style.cursor = overCharge ? 'grab' : 'default';
    });
    
    fieldCanvas.addEventListener('mouseup', () => {
        for (const charge of chargesField) {
            charge.dragging = false;
        }
        fieldCanvas.style.cursor = 'default';
    });
    
    // Verificar se o mouse está sobre uma carga na aba 1
    function isMouseOverFieldCharge(mouseX, mouseY, charge) {
        const dx = mouseX - charge.x;
        const dy = mouseY - charge.y;
        return dx * dx + dy * dy <= charge.radius * charge.radius;
    }
    
    // ========== ABA 2: CUBA ELETROLÍTICA COM PLACAS PARALELAS ==========
    const tankCanvas = document.getElementById('tankCanvas');
    const tankCtx = tankCanvas.getContext('2d');
    
    // Elementos de controle da aba 2
    const plateDistanceSlider = document.getElementById('plateDistance');
    const plateDistanceValue = document.getElementById('plateDistanceValue');
    const plateHeightSlider = document.getElementById('plateHeight');
    const plateHeightValue = document.getElementById('plateHeightValue');
    const voltageSlider = document.getElementById('voltage');
    const voltageValue = document.getElementById('voltageValue');
    const showFieldLinesCheckbox = document.getElementById('showFieldLines');
    const showEquipotentialsCheckbox = document.getElementById('showEquipotentials');
    const infoTankBtn = document.getElementById('infoTankBtn');
    
    // Estado da cuba eletrolítica
    let electrodes = [];
    let plateDistance = 200;
    let plateHeight = 160;
    let voltage = 12;
    let showFieldLines = true;
    let showEquipotentials = true;
    
    // Inicializar eletrodos (placas paralelas)
    function initializeElectrodes() {
        electrodes = [];
        const centerX = tankCanvas.width / 2;
        const centerY = tankCanvas.height / 2;
        
        // Placa positiva (esquerda)
        electrodes.push({
            type: 'plate',
            x: centerX - plateDistance / 2 - 5,
            y: centerY - plateHeight / 2,
            width: 10,
            height: plateHeight,
            voltage: voltage
        });
        
        // Placa negativa (direita)
        electrodes.push({
            type: 'plate',
            x: centerX + plateDistance / 2 - 5,
            y: centerY - plateHeight / 2,
            width: 10,
            height: plateHeight,
            voltage: 0
        });
    }
    
    // Desenhar a cuba eletrolítica
    function drawTank() {
        // Fundo da cuba (água)
        const waterGradient = tankCtx.createLinearGradient(0, 0, tankCanvas.width, tankCanvas.height);
        waterGradient.addColorStop(0, 'rgba(100, 150, 255, 0.3)');
        waterGradient.addColorStop(1, 'rgba(50, 100, 200, 0.5)');
        tankCtx.fillStyle = waterGradient;
        tankCtx.fillRect(0, 0, tankCanvas.width, tankCanvas.height);
        
        // Borda da cuba
        tankCtx.strokeStyle = '#8B4513';
        tankCtx.lineWidth = 5;
        tankCtx.strokeRect(5, 5, tankCanvas.width - 10, tankCanvas.height - 10);
        
        // Desenhar linhas de campo se habilitado
        if (showFieldLines) {
            drawFieldLinesTank();
        }
        
        // Desenhar linhas equipotenciais se habilitado
        if (showEquipotentials) {
            drawEquipotentialLines();
        }
        
        // Desenhar eletrodos
        drawElectrodes();
    }
    
    // Desenhar linhas de campo elétrico
    function drawFieldLinesTank() {
        const leftPlate = electrodes[0];
        const rightPlate = electrodes[1];
        const leftEdge = leftPlate.x + leftPlate.width;
        const rightEdge = rightPlate.x;
        
        tankCtx.strokeStyle = '#00ff00';
        tankCtx.fillStyle = '#00ff00';
        tankCtx.lineWidth = 1.5;
        
        // Número de linhas de campo baseado na altura das placas
        const numLines = Math.max(8, Math.floor(plateHeight / 20));
        const stepY = leftPlate.height / (numLines - 1);
        
        for (let i = 0; i < numLines; i++) {
            const startY = leftPlate.y + i * stepY;
            
            // Linha saindo da placa positiva
            tankCtx.beginPath();
            tankCtx.moveTo(leftEdge, startY);
            
            // Linha reta até a placa negativa (campo uniforme)
            tankCtx.lineTo(rightEdge, startY);
            tankCtx.stroke();
            
            // Seta no final
            const arrowLength = 10;
            tankCtx.beginPath();
            tankCtx.moveTo(rightEdge, startY);
            tankCtx.lineTo(rightEdge - arrowLength, startY - arrowLength/2);
            tankCtx.lineTo(rightEdge - arrowLength, startY + arrowLength/2);
            tankCtx.closePath();
            tankCtx.fill();
        }
    }
    
    // Desenhar linhas equipotenciais
    function drawEquipotentialLines() {
        const leftPlate = electrodes[0];
        const rightPlate = electrodes[1];
        
        tankCtx.strokeStyle = '#ff00ff';
        tankCtx.lineWidth = 2;
        tankCtx.setLineDash([5, 3]);
        
        // Número de linhas equipotenciais
        const numLines = 8;
        
        for (let i = 1; i < numLines; i++) {
            const potential = (i / numLines) * voltage;
            
            tankCtx.beginPath();
            
            // Calcular a posição x para este potencial
            const leftEdge = leftPlate.x + leftPlate.width;
            const rightEdge = rightPlate.x;
            const totalDistance = rightEdge - leftEdge;
            const x = leftEdge + totalDistance * (1 - potential / voltage);
            
            // Linha vertical (equipotencial)
            tankCtx.moveTo(x, leftPlate.y);
            tankCtx.lineTo(x, leftPlate.y + leftPlate.height);
            tankCtx.stroke();
            
            // Valor do potencial
            tankCtx.fillStyle = 'white';
            tankCtx.font = '12px Arial';
            tankCtx.textAlign = 'center';
            tankCtx.textBaseline = 'top';
            tankCtx.fillText(potential.toFixed(1) + 'V', x, leftPlate.y + leftPlate.height + 5);
        }
        
        tankCtx.setLineDash([]);
    }
    
    // Desenhar eletrodos
    function drawElectrodes() {
        for (const electrode of electrodes) {
            tankCtx.fillStyle = '#ff9900'; // Cor laranja para eletrodos
            tankCtx.strokeStyle = '#cc7700';
            tankCtx.lineWidth = 2;
            
            tankCtx.fillRect(electrode.x, electrode.y, electrode.width, electrode.height);
            tankCtx.strokeRect(electrode.x, electrode.y, electrode.width, electrode.height);
            
            // Indicar polaridade
            tankCtx.fillStyle = 'white';
            tankCtx.font = 'bold 14px Arial';
            tankCtx.textAlign = 'center';
            tankCtx.textBaseline = 'middle';
            const polarity = electrode.voltage === voltage ? '+' : '-';
            tankCtx.fillText(polarity, electrode.x + electrode.width/2, electrode.y + electrode.height/2);
        }
    }
    
    // Event listeners para a aba 2
    plateDistanceSlider.addEventListener('input', () => {
        plateDistance = parseInt(plateDistanceSlider.value);
        plateDistanceValue.textContent = `${plateDistance} px`;
        initializeElectrodes();
        drawTank();
    });
    
    plateHeightSlider.addEventListener('input', () => {
        plateHeight = parseInt(plateHeightSlider.value);
        plateHeightValue.textContent = `${plateHeight} px`;
        initializeElectrodes();
        drawTank();
    });
    
    voltageSlider.addEventListener('input', () => {
        voltage = parseInt(voltageSlider.value);
        voltageValue.textContent = `${voltage} V`;
        
        // Atualizar tensão dos eletrodos
        electrodes[0].voltage = voltage;
        
        drawTank();
    });
    
    showFieldLinesCheckbox.addEventListener('change', () => {
        showFieldLines = showFieldLinesCheckbox.checked;
        drawTank();
    });
    
    showEquipotentialsCheckbox.addEventListener('change', () => {
        showEquipotentials = showEquipotentialsCheckbox.checked;
        drawTank();
    });
    
    infoTankBtn.addEventListener('click', () => {
        showAvatarMessage("Em um campo uniforme entre placas paralelas, a relação E = V/d mostra que o campo é inversamente proporcional à distância entre as placas!", 1, 5000);
    });
    
    // ========== ABA 3: CAMPO ELÉTRICO VETORIAL ==========
    const vectorFieldCanvas = document.getElementById('vectorFieldCanvas');
    const vectorFieldCtx = vectorFieldCanvas.getContext('2d');
    
    // Elementos de controle da aba 3
    const charge5Slider = document.getElementById('charge5');
    const charge6Slider = document.getElementById('charge6');
    const charge5Value = document.getElementById('charge5Value');
    const charge6Value = document.getElementById('charge6Value');
    const resetVectorBtn = document.getElementById('resetVectorBtn');
    const infoVectorBtn = document.getElementById('infoVectorBtn');
    
    // Estado das cargas da aba 3
    let chargesVector = [
        { x: 150, y: 200, q: 60, radius: 20, dragging: false },
        { x: 400, y: 200, q: 60, radius: 20, dragging: false }
    ];
    
    // Atualizar os valores das cargas nos controles da aba 3
    function updateVectorChargeValues() {
        const charge5Sign = chargesVector[0].q > 0 ? '+' : '';
        const charge6Sign = chargesVector[1].q > 0 ? '+' : '';
        
        charge5Value.textContent = `${charge5Sign}${chargesVector[0].q} μC`;
        charge6Value.textContent = `${charge6Sign}${chargesVector[1].q} μC`;
        
        charge5Value.className = `charge-value ${chargesVector[0].q > 0 ? 'positive' : 'negative'}`;
        charge6Value.className = `charge-value ${chargesVector[1].q > 0 ? 'positive' : 'negative'}`;
    }
    
    // Desenhar os vetores de campo
    function drawVectorField() {
        const gradient = vectorFieldCtx.createLinearGradient(0, 0, vectorFieldCanvas.width, vectorFieldCanvas.height);
        gradient.addColorStop(0, 'rgba(10, 20, 40, 0.8)');
        gradient.addColorStop(1, 'rgba(5, 10, 20, 0.9)');
        vectorFieldCtx.fillStyle = gradient;
        vectorFieldCtx.fillRect(0, 0, vectorFieldCanvas.width, vectorFieldCanvas.height);
        
        const gridSize = 30;
        vectorFieldCtx.strokeStyle = '#00ff00';
        vectorFieldCtx.fillStyle = '#00ff00';
        vectorFieldCtx.lineWidth = 1.5;
        
        for (let x = gridSize; x < vectorFieldCanvas.width; x += gridSize) {
            for (let y = gridSize; y < vectorFieldCanvas.height; y += gridSize) {
                const field = calculateField(x, y, chargesVector);
                const magnitude = Math.sqrt(field.Ex * field.Ex + field.Ey * field.Ey);
                
                if (magnitude < 0.1) continue;
                
                // Normalizar e escalar o vetor
                const scale = Math.min(20, magnitude / 500);
                const dx = field.Ex / magnitude * scale;
                const dy = field.Ey / magnitude * scale;
                
                // Desenhar o vetor
                vectorFieldCtx.beginPath();
                vectorFieldCtx.moveTo(x, y);
                vectorFieldCtx.lineTo(x + dx, y + dy);
                vectorFieldCtx.stroke();
                
                // Desenhar a ponta da seta
                const angle = Math.atan2(dy, dx);
                const headLength = 8;
                const headAngle = Math.PI / 6;
                
                vectorFieldCtx.beginPath();
                vectorFieldCtx.moveTo(x + dx, y + dy);
                vectorFieldCtx.lineTo(
                    x + dx - headLength * Math.cos(angle - headAngle),
                    y + dy - headLength * Math.sin(angle - headAngle)
                );
                vectorFieldCtx.lineTo(
                    x + dx - headLength * Math.cos(angle + headAngle),
                    y + dy - headLength * Math.sin(angle + headAngle)
                );
                vectorFieldCtx.closePath();
                vectorFieldCtx.fill();
            }
        }
        
        // Desenhar as cargas
        for (const charge of chargesVector) {
            vectorFieldCtx.beginPath();
            vectorFieldCtx.arc(charge.x, charge.y, charge.radius, 0, Math.PI * 2);
            
            if (charge.q > 0) {
                vectorFieldCtx.fillStyle = 'red';
            } else if (charge.q < 0) {
                vectorFieldCtx.fillStyle = 'blue';
            } else {
                vectorFieldCtx.fillStyle = 'gray';
            }
            
            vectorFieldCtx.fill();
            vectorFieldCtx.strokeStyle = 'white';
            vectorFieldCtx.lineWidth = 2;
            vectorFieldCtx.stroke();
            
            vectorFieldCtx.fillStyle = 'white';
            vectorFieldCtx.font = 'bold 16px Arial';
            vectorFieldCtx.textAlign = 'center';
            vectorFieldCtx.textBaseline = 'middle';
            
            if (charge.q > 0) {
                vectorFieldCtx.fillText('+', charge.x, charge.y);
            } else if (charge.q < 0) {
                vectorFieldCtx.fillText('-', charge.x, charge.y);
            } else {
                vectorFieldCtx.fillText('0', charge.x, charge.y);
            }
        }
    }
    
    // Event listeners para a aba 3
    charge5Slider.addEventListener('input', () => {
        chargesVector[0].q = parseInt(charge5Slider.value);
        updateVectorChargeValues();
        drawVectorField();
    });
    
    charge6Slider.addEventListener('input', () => {
        chargesVector[1].q = parseInt(charge6Slider.value);
        updateVectorChargeValues();
        drawVectorField();
    });
    
    resetVectorBtn.addEventListener('click', () => {
        chargesVector[0].x = 150;
        chargesVector[0].y = 200;
        chargesVector[1].x = 400;
        chargesVector[1].y = 200;
        chargesVector[0].q = 60;
        chargesVector[1].q = 60;
        charge5Slider.value = 60;
        charge6Slider.value = 60;
        updateVectorChargeValues();
        drawVectorField();
    });
    
    infoVectorBtn.addEventListener('click', () => {
        showAvatarMessage("A representação vetorial do campo elétrico mostra claramente a direção e intensidade em cada ponto do espaço!", 2, 5000);
    });
    
    // ========== ABA 4: CAMPO MAGNÉTICO ==========
    const magneticCanvas = document.getElementById('magneticCanvas');
    const magneticCtx = magneticCanvas.getContext('2d');
    
    const currentSlider = document.getElementById('current');
    const currentValue = document.getElementById('currentValue');
    const intoPageBtn = document.getElementById('intoPageBtn');
    const outPageBtn = document.getElementById('outPageBtn');
    const infoMagBtn = document.getElementById('infoMagBtn');
    
    let current = parseFloat(currentSlider.value) || 10;
    let direction = 1; // 1 = saindo (⊙), -1 = entrando (⊗)
    const mu0 = 4 * Math.PI * 1e-7;
    
    // --- animação ---
    let animationOffset = 0;
    let lastTimestamp = null;
    let animateMagnetic = true;
    
    function updateCurrentDisplay() {
        // mostra sinal e valor claramente
        const sign = direction > 0 ? '+' : '-';
        currentValue.textContent = `${sign}${current.toFixed(1)} A`;
        currentValue.className = `charge-value ${direction > 0 ? 'positive' : 'negative'}`;
    }
    
    // nova função de desenho com setas tangenciais e movimento
    function drawMagneticField(timestamp) {
        if (!lastTimestamp) lastTimestamp = timestamp || performance.now();
        const now = timestamp || performance.now();
        const dt = (now - lastTimestamp) / 1000; // segundos
        lastTimestamp = now;
    
        // atualizar offset da animação proporcional à corrente
        // usar valor absoluto: maior corrente => setas mais rápidas
        animationOffset -= direction * current * dt * 15; // controle de velocidade (ajustável)
    
        magneticCtx.clearRect(0, 0, magneticCanvas.width, magneticCanvas.height);
        const cx = magneticCanvas.width / 2;
        const cy = magneticCanvas.height / 2;
    
        // fundo
        const gradient = magneticCtx.createRadialGradient(cx, cy, 50, cx, cy, 300);
        gradient.addColorStop(0, 'rgba(10, 20, 40, 0.8)');
        gradient.addColorStop(1, 'rgba(5, 10, 20, 0.9)');
        magneticCtx.fillStyle = gradient;
        magneticCtx.fillRect(0, 0, magneticCanvas.width, magneticCanvas.height);
    
        // fio central
        magneticCtx.beginPath();
        magneticCtx.arc(cx, cy, 15, 0, 2 * Math.PI);
        magneticCtx.fillStyle = '#ff9900';
        magneticCtx.fill();
        magneticCtx.strokeStyle = 'white';
        magneticCtx.lineWidth = 2;
        magneticCtx.stroke();
        magneticCtx.fillStyle = 'white';
        magneticCtx.font = 'bold 26px Arial';
        magneticCtx.textAlign = 'center';
        magneticCtx.textBaseline = 'middle';
        magneticCtx.fillText(direction > 0 ? '⊙' : '⊗', cx, cy);
    
        // círculos do campo
        magneticCtx.strokeStyle = '#00ff00';
        magneticCtx.lineWidth = 2;
    
        // parâmetros
        const minR = 40;
        const maxR = 180;
        const stepR = 30;
        const arrowSpacing = 40; // espaço entre setas ao longo do arco
        const arrowSize = 8;
    
        for (let r = minR; r <= maxR; r += stepR) {
            magneticCtx.beginPath();
            magneticCtx.arc(cx, cy, r, 0, 2 * Math.PI);
            magneticCtx.stroke();
    
            // desenhar setas ao longo do círculo
            // o número de posições depende do perímetro e arrowSpacing
            const circumference = 2 * Math.PI * r;
            const numPositions = Math.max(6, Math.floor(circumference / arrowSpacing));
            for (let i = 0; i < numPositions; i++) {
                // parâmetro t em [0,1)
                // adicionar animationOffset para deslocamento (movimento)
                const t = (i / numPositions + (animationOffset / circumference)) % 1;
                const angle = t * 2 * Math.PI;
    
                // posição da seta
                const x = cx + r * Math.cos(angle);
                const y = cy + r * Math.sin(angle);
    
                // tangente ao círculo -> direção do campo (90° da radial)
                // para campo anticlockwise (direction>0) a seta aponta tangentemente
                const tangentAngle = angle + (direction > 0 ? -Math.PI / 2 : Math.PI / 2);
    
                // desenhar triângulo orientado para tangentAngle
                magneticCtx.save();
                magneticCtx.translate(x, y);
                magneticCtx.rotate(tangentAngle);
    
                magneticCtx.beginPath();
                // triângulo apontando para a direita no sistema local
                magneticCtx.moveTo(0, 0);
                magneticCtx.lineTo(-arrowSize, -arrowSize / 2);
                magneticCtx.lineTo(-arrowSize, arrowSize / 2);
                magneticCtx.closePath();
                magneticCtx.fillStyle = '#00ff00';
                magneticCtx.fill();
                magneticCtx.restore();
            }
        }
    
        // continuar animação se habilitado
        if (animateMagnetic) {
            requestAnimationFrame(drawMagneticField);
        }
    }
    
    // listeners atualizados
    currentSlider.addEventListener('input', () => {
        current = parseFloat(currentSlider.value);
        updateCurrentDisplay();
        // a velocidade da animação mudará automaticamente (nós já usamos current no cálculo)
    });
    
    intoPageBtn.addEventListener('click', () => {
        direction = -1;
        updateCurrentDisplay();
    });
    
    outPageBtn.addEventListener('click', () => {
        direction = 1;
        updateCurrentDisplay();
    });
    
    infoMagBtn.addEventListener('click', () => {
        showAvatarMessage("O campo magnético de um fio é circular. Use a regra da mão direita para descobrir seu sentido!", 3, 6000);
    });
    
    // ========== INICIALIZAÇÃO ==========
    updateFieldChargeValues();
    drawFieldLines();
    
    initializeElectrodes();
    drawTank();
    
    updateVectorChargeValues();
    drawVectorField();
    
    updateCurrentDisplay();
    animateMagnetic = true;
    lastTimestamp = null;
    requestAnimationFrame(drawMagneticField);
    
    // Inicia a explicação automática na aba ativa
    startFieldExplanation();
    
    // Adicionar event listeners de arrastar para as outras abas
    function setupDragAndDrop(canvas, charges, drawFunction) {
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            for (const charge of charges) {
                const dx = mouseX - charge.x;
                const dy = mouseY - charge.y;
                if (dx * dx + dy * dy <= charge.radius * charge.radius) {
                    charge.dragging = true;
                    canvas.style.cursor = 'grabbing';
                    break;
                }
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            let overCharge = false;
            for (const charge of charges) {
                if (charge.dragging) {
                    charge.x = mouseX;
                    charge.y = mouseY;
                    drawFunction();
                } else {
                    const dx = mouseX - charge.x;
                    const dy = mouseY - charge.y;
                    if (dx * dx + dy * dy <= charge.radius * charge.radius) {
                        overCharge = true;
                    }
                }
            }
            
            canvas.style.cursor = overCharge ? 'grab' : 'default';
        });
        
        canvas.addEventListener('mouseup', () => {
            for (const charge of charges) {
                charge.dragging = false;
            }
            canvas.style.cursor = 'default';
        });
    }
    
    setupDragAndDrop(vectorFieldCanvas, chargesVector, drawVectorField);
    
    // Verificar se a síntese de voz está disponível
    if (!speechSupported) {
        console.warn("A síntese de voz não é suportada neste navegador. A funcionalidade de voz não estará disponível.");
        
        // Desativar botões de voz
        document.querySelectorAll('.avatar-controls button').forEach(btn => {
            btn.disabled = true;
            btn.textContent = "Voz não suportada";
        });
    }
</script>
</body>
</html>